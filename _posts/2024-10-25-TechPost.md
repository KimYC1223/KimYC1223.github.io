---
layout: post
pagination: 
  enabled: true
type: tech
date: 2024-10-25 01:01
category: Blog
title: "UniRX 소개"
subtitle: Reactive Extension for Unity 라이브러리 소개
writer: KimYC1223
post-header: true
header-img: bg.png
image: title.gif
tags: [Unity]
draft : false
---

{% capture img_url %}/assets/blog/{{page.date | date: "%Y-%m-%d"}}-TechPost{% endcapture %}

오늘은 우연히 알게된 Reactive Programming 이라는 것에 대해 알아보고 공유해보고자 한다.

<br><br>

---

# 🔷 개론

## 🔶 Reactive Programming

'비동기적 데이터 흐름' 을 처리하는 프로그래밍 기법이라는 뜻으로 모든 처리를 비동기적 데이터 스트림으로 간주, 

Observer 디자인패턴을 활용해서 이러한 비동기 이벤트를 처리하는 것이 핵심이다.

> In computing, reactive programming is a `declarative programming` paradigm concerned with `data streams and the propagation of change`.
>
> **변화의 전파와 데이터 흐름**과 관련된 **선언적 프로그래밍 패러다임** 이다.

<br>

### 💠 Data Streams And The Propagation Of Change

<Br>

좀 더 쉽게 풀어 쓰자면 일련의 흐름을 <span class="post-highlight">관찰할 수 있는 (Observable) 형태</span> 로 만들어서 값의 변화 /  이벤트의 발생을 감지하는 것으로

<br>

이 값들은 마치 물이 흐르는 것 처럼 <span class="post-highlight">스트림 (Stream)</span> 에 비유 할 수 있다.

<br>

경우에 따라 이 스트림의 값들을 필터링 하거나 버퍼링, 또는 다른 스트림의 값으로 바꾸는 등의 다양한 연산을 할 수 있다.

<Br>

이렇게 스트림을 조작해서 원하는 결과가 <span class="post-highlight">통지 (Subscribe)</span> 되므로 이 때 최종적으로 필요한 처리를 해줄 수 있게 된다.

<br>

<center>
<img src="{{img_url}}/img_0.webp" style="width:760px">
<figcaption style="margin-top:-20px;">Rx 프로그래밍의 기본적인 형태</figcaption>
</center>

### 💠 Declarative programming

최근 프로그래밍 패러다임은 크게 명령형 프로그래밍, 선언형 프로그래밍으로 구분지을 수 있다.

<div style="width:100%; display:inline-block; height:auto">
    <div style="width:calc(50% - 40px); padding : 20px; margin:20px; line-height:30px; background-color:#f9e8ee; border-radius:5px; float:left; ">
        <span style="color:#1e1e1e !import; font-size:20px; font-weight:bold">명령형 프로그래밍이란?</span><br><br>
        프로그래밍의 데이터와 상태를 변경시키는 구문의 관점에서 연산을 설명하는 프로그래밍 패러다임의 일종이다. 데이터와 상태를 어떻게 바꿀지 정의하는 프로그래밍 방법이다.<br>...<br><b>어떻게 계산을 할지보다는 무엇이 계산될 것인지를 정의한다는 생각으로 작성된다.</b>
    </div>
    <div style="width:calc(50% - 40px); padding : 20px; margin:20px; line-height:30px; background-color:#dffcfb; border-radius:5px; float:left; height:100%">
        <span style="color:#1e1e1e !import; font-size:20px; font-weight:bold">선언형 프로그래밍이란?</span><br><br>
         프로그램이 <b>어떤 방법</b>으로 해야 하는지를 나타내기보다 <b>무엇을</b> 할 것인지를 설명하는 경우에 선언형이라고 한다.
    </div>
</div>

간단히 말하여, 명령형 프로그램은 알고리즘을 명시하고 목표는 명시하지 않는 데 반해 선언형 프로그램은 목표를 명시하고 알고리즘을 명시하지 않는 것이다.

<br>



<br>

`Rx 프로그래밍` 은 Async Event(비동기 이벤트) 와  Observer 디자인패턴의 통지 처리를 이용해 

미리 이런 조건이 발생하면 이런 처리를 하라고 지시를 내려놓고 그 지시가 통과된 시점에서만 통지를 받는 형태가 된다.

<br>

`Reactive Programming` 은 `.NET` 뿐만 아니라 RxJava, RxJS, Rx++, ReactiveCocoa, RxScala, RxClojure, RxSwift 등등 

수많은 언어에서 사용 가능하도록 이미 많은 라이브러리가 제공 되고 있으며 사용자층 또한 매우 빠르게 늘어나고 있다.

<br>

> <i>정리하면... RX 프로그래밍은</i>
>
> <i><span style="font-size:20px; font-weight:bold;"> Observer Pattern + Iterator Pattern + Functional Programming</span> 이다.</i>

## 🔶 그럼 UniRX는 무엇인가?

<span class="post-highlight">UniRX</span>는 Reactive Programming을 C#에서 사용할 수 있게 만든 `.NET Reactive Extensions` 를 

한 일본인이 Unity 전용으로 최적화 하여 공개한 라이브러리이다.

<Br>
 
그런 만큼 더 가벼우며 UGUI, GameObject, Coroutine 등 유니티의 시스템과 매우 강력하고

직관적으로 연동이 되어있어 쉽게 Reactive Programming 의 사용이 가능하며,

<center>
<img src="{{img_url}}/img_1.png" style="width:801px">
<figcaption style="margin-top:-20px;">AssetsStor에 공개된 UniRX</figcaption>
</center>

[Unity AssetStor](https://assetstore.unity.com/packages/tools/integration/unirx-reactive-extensions-for-unity-17276)에서 패키지를 임포트하여 프로젝트에 쉽게 적용이 가능하다.

라이선스는 MIT이며, 소스코드도 [Github](https://github.com/neuecc/UniRx)에 공개하고있다.


<br><br>

---

# 🔷 예시를 들어볼까?

아무리 설명해도 감이 오지 않을 것 같다. 하나의 예시를 들어, UniRX에 대한 감을 익혀보자.

굉장히 간단한 질문이지만, 당신은...

<center>
<img src="{{img_url}}/img_2.png" style="width:800px">
</center>

물론 어렵지 않을 수 있다.

> * 마지막 클릭 했을 때 부터 일정 시간 이내라면 더블 클릭?
>
> * 클릭 횟수 변수와 타이머 변수를 필드에 정의?
>
> * `Update()` 내에 판정 처리를 구현?

예를들면, 다음과 같을 것이다.

``` cs
using UnityEngine;
using UnityEngine.UI;

public class DoubleClickHandler : MonoBehaviour
{
    public Text MyText; //Text GUI

    private bool isClicked = false; //첫번째 클릭이 된 상태인가
    private float clickTime = 0.0f; //첫번째 클릭 후 흐른 시간

    private void Update()
    {
        if (isClicked == true)  //이미 첫번째 클릭이 되었다면
        {
            clickTime += Time.DeltaTime();  //흐른 시간을 누적 시킨다
        }

        // 시간이 넘어 버렸을 때
        if(clickTime > 0.3f)
        {
            clickTime = 0.0f;
            isClicked = false;
        }
        // 클릭에 성공했을 때
        else if (Inpub.GetMouseButtonDown(0))  //마우스를 클릭 했다면
        {
            if (isClicked == false) //이번이 첫 클릭이라면
            {
                isClicked = true;
                return;
            }

            if (clickTime <= 0.3f) //첫 클릭 후 0.3초 이내에 클릭되었다면
            {
                //더블클릭 성공
                gameObject.GetComponent<Text>().text = "Double Clicked! Click Count";
            }
        }
    }
}
```
<br>

이를 UniRX를 사용한다면 아래와 같다.

``` cs
using UniRx;
using UniRx.Triggers;
using UnityEngine;
using UnityEngine.UI;

public class DoubleClickHandlerRX : MonoBehaviour
{
    public Text MyText;

    private void Start()
    {
        //매프레임 마우스 클릭 이벤트를 관찰하는 스트림을 정의 한다.
        var clickStream = UpdateAsObservable()
            .Where(_ => Input.GetMouseButtonDown(0));

        //이 스트림에 0.3초 간 흘러들어오는 (마우스클릭) 이벤트를 모은다.(Buffer)
        clickStream.Buffer(clickStream.Throttle(TimeSpan.FromMilliseconds(300)))
            .Where(x => x.Count >= 2)             //(마우스클릭) 이벤트가 2회 이상 발생한 경우만 필터링
            .SubscribeToText(MyText, x =>         //위 조건을 충족한 경우 GUI의 MyText 컴포넌트에 정보 출력
                $"Double Clicked! Click Count", );
    }
}
```

*출처: [아마군의 Dev로그:티스토리](https://skuld2000.tistory.com/31)*

<br>

다음과 같은 장점이 있는걸로 보인다!

* 코드가 간결해졌다.

* 쓸데없는 Flag 변수나 시간을 저장하는 임시 변수의 선언이 줄어들었다.

* Update()의 로직을 모두 스트림화하여 Update() 없앴다.

<br>

음... 아직 뭔진 모르겠지만 아직 굳이? 라는 느낌이 든다.

<center>
<img src="{{img_url}}/img_3.webp" style="width:240px">
<figcaption style="margin-top:-20px;">그래서 어쩌라구요?</figcaption>
</center>



다음과 같은 특징을 가지고 있다.

* 비동기 데이터 스트림을 중심으로 동작한다.
* 스트림 내의 데이터에 변화가 발생했을 때 반응형으로 기능이 동작하는 방식을 사용한다.
* 시간을 상당히 간단하게 취급할 수 있게 된다.
