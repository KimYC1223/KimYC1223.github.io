---
layout: post
pagination: 
  enabled: true
type: tech
date: 2025-05-03 17:21
category: Blog
title: "[VContainer] Unity와 Dependency Injection"
subtitle: "Unity의 의존성 주입(DI)과 VContainer 에셋 소개"
writer: KimYC1223
post-header: false
image: title.gif
tags: [JobPreparation]
draft : false
---

{% capture img_url %}/assets/blog/{{page.date | date: "%Y-%m-%d"}}-TechPost{% endcapture %}

<span class="post-h1">&nbsp;1&nbsp;&nbsp;|&nbsp;&nbsp;개요&nbsp;</span>

이번에 이직하게된 [DEVSISTERS의 채용공고](/blog/2025/05/01/TechPost)를 보니, 팀에서 <span class="post-highlight">VContainer</span>라는 플러그인을 사용하는 것 같았다. 물론 공고에 따르면 입사 후 배워 나갈 수 있는 것으로 보였지만, 그래도 미리 공부를 해두면 배울 때 훨씬 빠르게 배울 수 있을 것 같아서, 정리를 해보고자 한다.

<center>
<img src="{{img_url}}/img_00.png" style="max-width:450px; width:100%; border:1px solid #000000;">
<figcaption style="margin-top:-30px;">STUDIO KINGDOM 채용 공고중 일부</figcaption>
</center>

먼저 의존성 주입이란 무엇인지 알아보고, Unity에서 이를 지원하기 위한 3rd 파티 플러그인인 VContainer에 대해 알아보도록 한다.

<br><br>

----

<span class="post-h1">&nbsp;2&nbsp;&nbsp;|&nbsp;&nbsp;C#과 의존성 주입 (Dependency Injection)&nbsp;</span>

## 🔷 2-1. 의존성 주입이란?

<span class="post-highlight">의존성 주입(Dependency Injection)</span>은 클래스가 필요한 의존 객체를 외부로부터 전달받는 설계 방식이다. 이름은 굉장히 어렵게 들리지만, 개념 자체는 단순하다. 객체 내부에서 직접 다른 객체를 생성하지 않고, 필요한 것을 외부에서 `주입받는다` 는 점이 핵심이다.

이해를 돕기위해, 코드를 살펴보도록 하자. 아래 코드는 의존성 주입이 적용되지 않은 일반적인 C#코드의 한 예이다. 게임 전반을 관리하는 매니저 클래스인 `GameManager` 와, 외부와 연결된 `GameServer`가 있다. 

먼저, `GameManager`는 아래와 같다.

``` cs
public class GameManager
{
    // 멤버 변수
    private GameServer gameServer;
    private int score;

    // 생성자
    public Player()
    {
        gameServer = new GameServer(); // 직접 생성
    }

    // 점수 저장 메서드
    public void SaveScore()
    {
        gameServer.SaveData(score);
    }
}
```

`GameServer` 클래스는 다음과 같다고 하자.

``` cs
public class GameServer
{
    public void SaveData(int score)
    {
        // =======================================
        //  서버 통신용 코드
        // =======================================

        Console.WriteLine($"저장된 점수 : ${score}");
    }
}
```

`GameManager`와 `GameServer`는 서로 <span class="post-highlight">Composition(구성)</span>관계임을 알 수 있다. 이를 UML 클래스 다이어그램으로 표현하면 다음과 같다.

> Composition(구성) 관계에 대해 잘 모른다면, [이전 블로그 게시글](/blog/2024/04/19/TechPost)의 `Relationships between classes` 부분을 참고하면 좋을 듯 하다.

<center>
<img src="{{img_url}}/img_01.png" style="max-width:527px; width:100%;">
<figcaption style="margin-top:-30px;">GameManager와 GameServer <i><b>(그림 A)</b></i></figcaption>
</center>

이 방식의 문제는 <span class="post-highlight">GameManager가 GameServer의 구체적인 구현에 강하게 묶여 있다는 점</span>이다. 이는 다음과 같은 문제점을 유발 할 수 있다.

<br>

### 🔶 문제점 1. 테스트의 어려움

`GameManager` 를 테스트하기 위해 `GameServer` 를 사용할 경우, 실제 서버에 테스트 데이터가 저장될 위험이 있기 때문에, 테스트를 할 때에는 모의객체 *(Mock)* 를 써야할 것이다. 따라서 테스트용 모의객체 클래스 `TestGameServer` 를 만든 뒤, `GameManager` 생성자에서 `new GameServer()` 대신 `new TestGameServer()` 로 객체를 만들도록 `코드를 수정하여`  멤버 변수에 저장해야 한다. 그러나 이는 곧 테스트를 할 때 마다 이런식으로 `GameManager` 의 코드를 변경해주어야 한다는 뜻인데 이런식의 코드 변경은 휴먼에러가 생길 수 있는 큰 구멍으로, 코드의 안정성을 대폭 떨어트린다.

> 모의객체(Mock)를 잘 모른다면, [이전 블로그 게시글](/blog/2024/02/23/TechPost)의 `대역의 종류` 부분을 참고하면 좋을 듯 하다.

<br>

### 🔶 문제점 2. 낮은 확장성

개발이 진행되면서, `GameServer`를 `CloudGameServer` 따위로 교체할 필요가 생겼다고 하자. 이럴 경우 개발자가 `GameManager` 클래스의 코드를 변경해 주어야 할텐데, 이는 문제점 1번과 마찬가지로 코드의 확장성이 부족해지는 요인이 될 수 있다.

<br>

이런 문제들이 있다는것은 잘 알았다. **그런데 그럼 어떻게 바꿔야 하는가?** 일단, **구현** 된 객체를 의존하지 않도록, 새로운 인터페이스를 만들어준다.

아래는 새로 만든 `IGameServer` 인터페이스이다.

``` cs
public interface IGameServer
{
    void SaveData(int score);
}
```

그리고 `IGameServer` 라는 인터페이스가 생겼으니, 인터페이스를 구현하도록 기존 `GameServer` 를 변경해준다.

``` cs
public class GameServer : IGameServer  // IGameServer 구현
{
    public void SaveData(int score)
    {
        // =======================================
        //  서버 통신용 코드
        // =======================================

        Console.WriteLine($"저장된 점수 : ${score}");
    }
}
```

이 인터페이스를 구현하면 테스트용 모의객체도 쉽게 만들 수 있다. 예를 들면 다음과 같다.

``` cs
public class MockGameServer : IGameServer
{
    public bool WasSaveCalled { get; private set; } = false;

    public void SaveData(int score)
    {
        WasSaveCalled = true;
        Console.WriteLine($"[테스트용] 저장된 점수: {score}");
    }
}
```

<br>

또한 `GameManager` 의 멤버 변수를 구상클래스인 `GameServer` 를 자료형으로 두는게 아니라 `IGameServer` 를 자료형으로 두도록 변경한다. 그 후 `GameManager` 에서 이를 직접 생성해서 사용하는 것이 아니라 **외부에서 주는 객체를 받아와서 저장하도록** 만들어준다. 즉, 두 클래스를 **Composition** 관계에서 **Aggregation** 관계로 만들어 주도록 수정한다.

``` cs
public class GameManager
{
    // 멤버 변수 ( IGameServer 인터페이스 사용 )
    private IGameServer gameServer;

    // 생성자에서 받아와서 멤버 변수에 저장하도록 변경 ( Aggregation관계가 되도록 )
    public GameManager(IGameServer server)
    {
        gameServer = server;
    }

    // 후략
}
```

이로써 `GameManager`는 생성될 때 변수로 어떤 인스턴스를 받느냐에따라 동작이 달라지게 된다. 기존과 다르게 `GameManager` 의 코드의 변경 없이 가능해 졌다는 점이다.

즉, 다양한 상황에 따라 다른 구현을 유연하게 주입할 수 있다. 예를 들어 테스트에서는 다음과 같이 가짜 객체를 전달할 수 있다.

``` cs
var mockGameServer = new MockGameServer();
var manager = new GameManager(server : mockGameServer);
```

이것이 바로 <span class="post-highlight">의존성 주입</span>이다!

**`의존성 주입(Dependency Injection / DI)` 은 객체가 직접 필요한 의존성을 생성하는 것이 아니라, 외부에서 전달받는 방식이다.** 이를 통해 객체 간의 결합도를 낮추고, 보다 유연하고 확장 가능한 구조를 만들 수 있다. 특히 테스트 코드 작성 시, 실제 서버 대신 테스트용 객체를 주입할 수 있어 테스트의 정확성과 효율성이 향상된다. 또한 새로운 기능을 추가하거나 기존 로직을 수정할 때도 최소한의 변경으로 적용이 가능하다는 장점이 있다. 결국 이는 유지보수성과 코드의 품질을 높이는 데 매우 중요한 역할을 한다.

개념적으로는 **`레고 블록`** 에 비유할 수 있다. 조립식 블록처럼, 각 구성 요소를 갈아 끼우는 것이 쉬워진다. 하나의 블록(클래스)이 다른 블록에 결합될 때, 직접 붙이는 것이 아니라 외부에서 알맞게 연결해주는 셈이다.

이러한 유연성이 생기는 이유는 `GameManager` 가 구상클래스에 의존성이 걸려있는 것이 아니라 인터페이스에 의존성이 걸리도록 변경했기 때문이다. UML 그림으로 보면 다음과 같다.

<center>
<img src="{{img_url}}/img_02.png" style="max-width:758px; width:100%;">
<figcaption style="margin-top:-30px;">DI를 적용한 버전 <i><b>(그림 B)</b></i></figcaption>
</center>

자세히 보면 포스트의 첫번째 UML <i><b>(그림 A)</b></i> 과 이번 UML <i><b>(그림 B)</b></i> 에서 `화살표의 방향` 이 조금 달라진 것을 볼 수 있다. 첫번째 에서는 한 방향 *(왼쪽에서 오른쪽으로 향함)* 이었는데, 이번 UML 에서는 클래스 사이에 인터페이스가 생기고, 두 방향으로 된 것을 볼 수 있다. *(양쪽에서 가운데로 향함)* 이를 제어의 역전, <span class="post-highlight">Inversion Of Control</span> 이라고 한다.

<center>
<img src="{{img_url}}/img_03.png" style="max-width:285px; width:100%; padding:10px;">
<figcaption style="margin-top:-30px;">제어의 역전 / IOC(Inversion Of Control)</figcaption>
</center>

<br>

#### 📚 참고 문서

* <b>[ 5분 개발지식 유튜브 ]</b> : <a href="https://velog.io/@kwontae1313/%EC%A0%9C%EC%96%B4-%EC%97%AD%EC%A0%84IoC%EA%B3%BC-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85DI" class="post-no-highlight-link">의존성 주입 3분만에 이해하기 (Dependency Injection, Inversion of Control)</a>
* <b>[ dev.KwonTaeHyeong 블로그 ]</b> : <a href="https://www.youtube.com/watch?v=1vdeIL2iCcM" class="post-no-highlight-link"> 제어의 역전(IoC)</a>

<br>

---

## 🔷 2-2. IoC Container & Composition Root

다시 코드를 살펴보자.

``` cs
public class GameManager
{
    // 멤버 변수 ( IGameServer 인터페이스 사용 )
    private IGameServer gameServer;

    // 생성자에서 받아와서 멤버 변수에 저장하도록 변경
    public GameManager(IGameServer server)
    {
        gameServer = server;
    }

    // 후략
}
```

앞서 설명한 대로, 구상클래스의 의존성을 낮추기 위해 `gameServer` 필드에 객체를 할당할 때 직접 `new ()` 로 객체를 만들지 않도록 했다. 대신 생성자에서 `IGameServer` 인터페이스를 구현한 인스턴스를 받아오도록 변경했다. 

이로써 `GameManager` 클래스는 `GameServer` 라는 구상클래스를 알 필요가 없게 됐지만, 대신 다른 곳에서 `GameServer` 인스턴스를 만들어서 `GameManager` 생성자에게 전달해 주어야만 하게 되었다. 이러한 객체 생성을 담당하고 의존성을 주입하는 역할을 하는 프레임워크를 <span class="post-highlight">IoC Container</span>라고 하며,
IoC Container에 의존성 구성을 알려주는 역할을 하는 클래스를 <span class="post-highlight">Composition Root</span>라고 한다.

``` cs
public class Program
{
    static void Main(string[] args)
    {
        var compositionRoot = new CompositionRoot();
        compositionRoot.Run();
    }
}

public class CompositionRoot
{
    public void Run()
    {
        // 수동으로 의존성을 주입했지만, 실제 DI 프레임워크가 내부적으로 수행하는 방식과 유사하다
        IGameServer gameServer = new GameServer();
        GameManager gameManager = new GameManager(gameServer);
    }
}
```

일반적으로 생각해보면 다른 클래스를 사용하려는 곳에서 객체를 결정/생성하고 그 객체의 메서드를 호출하는 방식이 자연스러울 수 있다. `Program` 클래스가 `GameManager` 를 생성하고, 그 `GameManager` 에서 `GameServer` 를 생성하는 식이다. <span class="post-highlight">제어의 역전 (Inversion of Control)</span> 이란 이러한 제어의 흐름을 역전하는 것을 의미한다.

<center>
<img src="{{img_url}}/img_04.png" style="max-width:662px; width:100%;">
<figcaption style="margin-top:-30px;">기존 방식을 나타내는 UML</figcaption>
</center>

**IoC** 가 적용된다면 `CompositionRoot` 가 *(때로는 I 라고도 부른다.)* 그러한 업무를 모두 담당하게 된다. 필요한 객체를 생성하고, 관계에 맞게 전달하여 각 클래스간의 의존성을 낮춰주게 된다.

<center>
<img src="{{img_url}}/img_05.png" style="max-width:687px; width:100%;">
<figcaption style="margin-top:-30px;">IoC가 적용된 UML</figcaption>
</center>

가끔 IoC Container를 Factory Pattern과 혼동하여 IoC 관련 라이브러리를 그냥 Factory처럼 사용하는 경우도 많이 보았는데, Factory는 단순히 object를 생성하는 assembler에 가깝고 IoC Container는 거기에 제어의 역전 개념이 적용되어야 한다. IoC Container를 그냥 사용한다고 제어가 역전 되는 게 아니다.

<br>

#### 📚 참고 문서

* <b>[ Develogs 블로그 ]</b> : <a href="https://develogs.tistory.com/19" class="post-no-highlight-link"> 제어의 역전(Inversion of Control, IoC) 이란?</a>

<br>

---

## 🔷 2-3. Unity와 Dependency Injection

C#에서는 DI가 비교적 자연스럽게 적용되지만, **Unity에서는 몇 가지 구조적인 제약 때문에 DI를 도입하는 데 어려움이 있다.** `MonoBehaviour` 기반 구조, 생명주기 관리, GameObject 종속성 등이 복합적으로 작용하며 일반적인 DI 방식과 충돌한다.

<center>
<img src="{{img_url}}/img_06.gif" style="max-width:253px; width:100%; margin-top:-30px;">
<figcaption style="margin-top:-30px;">어림도없지! 바로 쓸 수 없다!</figcaption>
</center>

 대표적인 예로, `MonoBehaviour` 를 상속받은 클래스를 새롭게 추가하려고 하는 경우를 생각해보자. 문제는 `MonoBehaviour` 는 우리가 직접 `new ()` 키워드로 인스턴스 생성을 할 수 없고, 반드시 GameObject에 붙여야만 한다는 점이다.
 
``` cs
public class MyGameMonster : MonoBehaviour
{
    // ...
}

public class MyGameSpawner
{
    var monster = new MyGameMonster(); // 컴파일은 되지만 제대로 작동하지 않음
}
```
 
위와 같은 코드는 컴파일은 정상적으로 되지만, 다음과 같은 에러가 뜨는것을 볼수있다. 

<center>
<img src="{{img_url}}/img_07.png" style="max-width:256px; width:100%; margin-top:-30px;">
<figcaption style="margin-top:-30px;">new 키워드로 MonoBehaviour 클래스를 생성하면 발생하는 오류</figcaption>
</center>

<div style="padding:10px 10px 10px 30px; border-radius:8px; background-color:#f2f2f2; margin-bottom:30px">
<details style="transition:1s">
<summary style="font-size:18px">
<b style="cursor:pointer">&nbsp; 🔎 Why can't create MonoBehaviour with “new’ keyword?</b>
</summary>
<div style="color:#a2a2a2">
<hr style="border:1px solid #666666">
<p><i>MonoBehaviours are Components. This means they are inextricably attached to GameObjects at all times. If you create a MonoBehaviour with new, then obviously it is not attached to a GameObject. It cannot exist in this state, so Unity gives you a warning that this is bad. ... MonoBehaviours are meant to only exist when they are attached to GameObjects. You can create one by Instantiating an existing one (such as from a prefab), or by using the AddComponent method on GameObject.</i></p>
<p style="color:#666666">MonoBehaviour는 컴포넌트입니다. 즉, 항상 게임 오브젝트에 불가분의 관계로 연결되어 있습니다. new를 사용하여 MonoBehaviour를 생성하면 게임 오브젝트에 연결되지 않습니다. 이 상태로는 존재할 수 없으므로 Unity는 이러한 상태가 좋지 않다는 경고를 표시합니다. ... MonoBehaviour는 게임 오브젝트에 연결될 때만 존재합니다. 기존 MonoBehaviour를 인스턴스화하거나(예: 프리팹에서) GameObject의 AddComponent 메서드를 사용하여 MonoBehaviour를 생성할 수 있습니다.</p>
</div>
</details>
</div>

또한 Unity는 `MonoBehaviour` 의 생성자를 호출하지 않기 때문에, <span class="post-highlight">생성자 주입(Constructor Injection)</span>이 불가능하다. 의존성 주입의 가장 일반적인 방식이 막혀 있는 셈이다.

``` cs
public class Player : MonoBehaviour
{
    private readonly IGun _gun; // 컴파일 에러

    public Player(IGun gun) { ... } // 호출되지 않음
}
```

대신 Unity에서는 대부분 `Start()`, `Awake()` 같은 생명주기 메서드에서 의존 객체를 초기화하지만, 이 역시 명시적인 주입보다는 `Find(...)`나 `GetComponent(...)` 등으로 직접 의존성을 해결하는 방식이 많다. **이 방식은 외부에서 객체 간 의존 관계를 제어하기 어렵게 만든다.** 이는 다음과 같은 코드로 이어지기 쉽다.

``` cs
public class ItemManager : MonoBehaviour
{
    // ...
}

public class Item : MonoBehaviour
{
    private ItemManager manager;

    void Awake()
    {
        manager = FindObjectOfType<ItemManager>();
    }
}
```

이러한 관계는 다음과 같은 문제가 있다.

### *1. 명시적인 의존 관계가 코드에 드러나지 않는다*

지금은 코드가 짧아 `Item` 클래스가 `ItemManager`에 대해 의존성을 가지고 있는 것을 쉽게 파악할 수 있지만, 만약 Awake 부분의 코드가 길어지거나, 추가적인 로직이많이 들어가게되면 금방복잡해 지게되어 의존관계 파악이 어려워지게 된다.

### *2. 객체의 생애 주기를 외부에서 제어할 수 없다*

Unity에서는 대부분의 객체가 다음과 같은 방식으로 만들어진다.

* Scene에 미리 배치된 GameObject

* `Instantiate()` 를 통해 런타임에 생성

* `ScriptableObject.CreateInstance()` 호출

예를 들어 다음과 같이 `Item` 오브젝트를 `Instantiate()` 할 경우를 생각해보자.

``` cs
var item = Instantiate(itemPrefab);
```

이 객체는 Unity 내부에서 `Awake()` → `OnEnable()` → `Start()` 순서로 생명주기를 자동 처리하며, 우리는 그 흐름을 외부에서 개입하기 어렵다. 즉, 이 시점에 <span class="post-highlight">Enemy가 생성될 때 필요한 GameManager가 이미 준비되어 있을까?</span> 같은 질문을 코드 수준에서 보장하기 힘들다. 결국 `FindObjectOfType`, `DontDestroyOnLoad`, `StartCoroutine` 등을 동원해 생명주기를 **땜질**식으로 맞춰야 한다.

요약하면, MonoBehaviour 를 상속받은 class는 객체의 생성 시점과 파괴 시점을 개발자가 명시적으로 통제할 수 없고, 의존성 주입을 동기적으로 안전하게 보장하기 어려우며 라이프사이클이 Unity 내부 구현에 강하게 의존한다는 걸 의미한다.

<br>

이런 문제를 해결하기 위해 Unity에서는 의존성 주입이 가능한 구조를 강제로라도 만들 필요가 있다. 물론 직접 DI 컨테이너를 구현하거나 억지로 주입 방식을 흉내 낼 수도 있지만, 이는 구조를 더 복잡하게 만들 뿐이다.

이 지점에서 등장하는 것이 Unity에 특화된 DI 프레임워크, <span class="post-highlight">VContainer</span>이다.

<br>

#### 📚 참고 문서

* <b>[ Unity 공식 문서 ]</b> : <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.html" class="post-no-highlight-link">MonoBehaviour</a>
* <b>[ Unity 포럼 ]</b> : <a href="https://discussions.unity.com/t/cannot-create-monobehaviour-with-new-keyword/858172" class="post-no-highlight-link">Cannot create MonoBehaviour with “new’ keyword?</a>
* <b>[ 나의 삽질일지 블로그 ]</b> : <a href="https://prhymery.github.io/docs/Unity/MonoBehaviour/" class="post-no-highlight-link"> MonoBehaviour</a>


<br><br>

----

<span class="post-h1">&nbsp;3&nbsp;&nbsp;|&nbsp;&nbsp;VContainer&nbsp;</span>

## 🔷 3-1. VContainer란

<span class="post-highlight">VContainer</span>는 Unity에 최적화된 경량 `Dependency Injection 프레임워크` 다. Zenject와 같은 기존 DI 프레임워크가 가진 복잡성, 런타임 비용, 학습 난이도 등의 문제를 보완하기 위해 만들어졌으며, 성능과 생산성 모두를 고려한 구조를 지향한다. VContainer는 일본의 게임 개발자 [hadashiA](https://github.com/hadashiA) 가 개발하고 있으며, [GitHub에서 오픈소스](https://github.com/hadashiA/VContainer)로 관리된다. Unity Asset Store에 등록된 유료 패키지는 아니지만, 오픈소스 프로젝트로서 [MIT 라이선스](https://namu.wiki/w/MIT%20%ED%97%88%EA%B0%80%EC%84%9C#toc:~:text=%EA%B7%B8%20%ED%95%9C%20%EC%98%88%EC%8B%9C%EB%8B%A4.-,2.%20%EC%9A%94%EC%95%BD,-%5B%ED%8E%B8%EC%A7%91%5D) 하에 자유롭게 사용할 수 있다.

> VContainer의 "V"는 Unity의 첫 글자 "U"를 더 얇고 견고하게 만드는 것을 의미한다고 한다.

<center>
<a href="https://github.com/hadashiA/VContainer" target="_blank" style="display:inline-block;text-decoration:none;background-color:#FFFFFF00 !important">
<img src="{{img_url}}/img_08.png" style="max-width:857px; width:100%; padding:10px;"></a>
<figcaption style="margin-top:-30px;">VContainer 소개 Github 페이지 (클릭시 repo로 이동)</figcaption>
</center>

`VContainer`는 일반적인 .NET DI 프레임워크를 Unity에 그대로 적용하는 데 한계가 있다는 점에서 출발한다. 앞에서 설명했듯 Unity는 `MonoBehaviour`, `ScriptableObject`, `GameObject` 기반의 독특한 실행 환경을 가지고 있는데, VContainer는 이 문제를 해결하기 위해, 다음과 같은 특징을 제공한다.

### 🔸 Unity 생명주기와 자연스럽게 통합되는 LifetimeScope 구조

VContainer는 Unity의 씬 시스템과 라이프사이클을 깊이 있게 통합하는 구조를 제공한다. 가장 핵심적인 개념은 후술할 <span class="post-highlight">LifetimeScope</span>이다. 이를 통해 **Unity 특유의 씬 전환**, **프리팹 Instantiate**, **DontDestroyOnLoad** 구조에서도 명확하게 의존성 범위를 나눌 수 있다. 또한 MonoBehaviour의 `Awake()`, `Start()` 타이밍 전에 이미 의존성이 주입되므로, 기존 Unity 코드 흐름을 크게 변경하지 않아도 된다.

### 🔸 Constructor Injection을 지원하는 방식으로 비-MonoBehaviour 객체를 안전하게 관리

Unity의 MonoBehaviour가 아닌 일반 순수 C# 클래스에게도 전통적인 방식의 **생성자 주입** 형태로 의존성을 주입할 수 있다. 이런 비-MonoBehaviour 클래스에 대해서는 VContainer가 DI 컨테이너처럼 생성자를 호출하고, 내부 의존성을 자동으로 주입해주게 된다.

### 🔸 Zero GC(가비지 컬렉션 없음) 을 지향하는 경량 컨테이너

VContainer의 가장 큰 특징 중 하나는 `Zero GC(가비지 컬렉션 없음)` 을 지향하는 구조다. 기존 DI 프레임워크들은 내부적으로 Reflection이나 Expression Tree를 활용하는 경우가 많아, 런타임 중 할당이 발생하고 이는 곧 GC 수집 타이밍에 영향을 준다. 그러나 VContainer는 **컴파일 타임 분석**과 **코드 생성 방식**을 활용해, 런타임 오버헤드를 최소화한다고 한다. 의존성 해석과 인스턴스 생성은 초기화 단계에서 한 번 수행되고, 이후에는 GC에 영향을 주지 않는 방식으로 동작한다. 이러한 특성 덕분에 VContainer는 모바일, 콘솔 등 GC 민감한 플랫폼에서도 안정적으로 사용할 수 있다!

<br>

즉, VContainer는 Unity의 고유한 구조에 잘 녹아드는 DI 프레임워크로, 기존의 .NET DI 컨테이너들과는 철학이 다르다. **"Unity 프로젝트에서 DI를 실용적으로 쓸 수 있을까?"** 라는 질문에 실질적인 해답을 제공한다는 점에서 의미가 크다.

<br>

---

## 🔷 3-2. VContainer 설치

다음과 같은 방식으로 VContainer를 설치할 수 있다. 지원하는 Unity 에디터 버전은 `2018.4` 이상 버전을 사용해야 한다.

> (2025.05 기준, ECS(Entity Component System)과 함께 사용하고 싶다면 Untity 2019.3 이상을 사용해야한다.)

1. Unity 프로젝트의 Root에 존재하는 `Packages` 폴더로 이동하여 `manifest.json` 파일을 연다.
2. `dependencies` 항목에 다음과 같은 내용을 추가한다.
``` json
{
    "dependencies": 
    {
        //...(중략)
        "jp.hadashikick.vcontainer": "https://github.com/hadashiA/VContainer.git?path=VContainer/Assets/VContainer#1.16.8"
    }
}
```
3. 에디터로 돌아오면, UPM이 자동으로 패키지를 설치한다.

<br>

---

## 🔷 3-3. VContainer 기본 사용법

기본적으로, VContainer를 사용하는 방법은 크게 다음 3단계로 나누어진다.

> 1. `LifetimeScope`를 상속한 컴포넌트를 Scene에 추가한다. `LifetimeScope` 하나당 **container** 하나와 **scope** 하나를 가지고 있다.
> 2. `LifetimeScope`를 상속한 클래스에서, 주입하고자하는 종속성을 구성하고 등록한다. (이를 CompositionRoot라고 한다.)
> 3. Scene을 Play하면 `LifetimeScope`가 필요한 객체를 생성하고, 종속성을 주입힌다.

<br>

라고 한다면 이해하기 어려울 것이므로, 간단한 코드를 통해 살펴 보도록 하자. 예를들어, 게임에 하나의 `EquipmentManager`와 `StatManager`가 있다고하자. 캐릭터의 Stat을 계산할 땐 장비의 능력치가 필요하므로, `StatManager`는 `EquipmentManager`에게 의존성을 가지고 있다. 테스트할 것이기 때문에, 다음과 같은 아주 간단한 코드를 작성해 보았다.

``` cs
public interface IEquipmentManager
{
    public float GetAttackPower();
}

public class EquipmentManager : IEquipmentManager
{
    public float GetAttackPower()
    {
        return 100f;
    }
}
```

그리고 이를 참조하는 `StatManager` 클래스를 작성해준다.

``` cs
public interface IStatManager
{
    public float GetTotalAttackPower();
}

public class StatManager : IStatManager
{
    private IEquipmentManager _equipmentManager;
    private float _characterAttackPower = 100f;

    public StatManager(IEquipmentManager equipmentManager)
    {
        _equipmentManager = equipmentManager;
    }

    public float GetTotalAttackPower()
    {
        return _characterAttackPower +
            _equipmentManager.GetAttackPower();
    }
}
```

이제 이 두 클래스를 VContainer를 연결해 보도록 하자. 

Unity 프로젝트에 가서 새로운 C# 파일을 만들고 이름을 `MyGameLifetimeScope.cs` 로 설정해 둔다. 사실 다른 이름이어도 별 상관없지만, `~ LifetimeScope.cs` 로 끝나는 파일을 만들면 자동으로 코드 템플릿이 적용되기 때문에 편리하기 때문이다. 그리고, `Configure` 메서드에 두 클래스를 등록해 둔다. 이를 통해 두 클래스를 등록해둔다.

``` cs
using VContainer;
using VContainer.Unity;

public class MyGameLifetimeScope : LifetimeScope
{
    protected override void Configure(IContainerBuilder builder)
    {
        builder.Register<IEquipmentManager, EquipmentManager>(Lifetime.Singleton);
        builder.Register<IStatManager, StatManager>(Lifetime.Singleton);
    }
}
```

구현한 내용을 UML로 그려보면 다음과 같다.

<center>
<img src="{{img_url}}/img_11.png" style="max-width:600px; width:100%; margin-top:-30px;">
<figcaption style="margin-top:-30px;">구현한 내용을 표현한 UML</figcaption>
</center>

여기서 `Lifetime.Singleton` 이라는 부분을 볼 수 있는데, 이 enum값은 <span class="post-hightlight">의존성의 생명주기</span>를 정의하는데 사용되는 타입이다. 이는 객체가 언제 생성되고 언제 파괴되는지를 결정하는 **중요한 설정**이다. 문서에 따르면, VContainer는 다음과 같은 3가지 주요 Lifetime을 제공한다.

> ### 🔸 `Lifetime.Singleton`
> 
> 애플리케이션 전체에서 한 번만 생성되며, 모든 요청에 대해 **같은 인스턴스**가 제공된다. 주로 **설정 값, 서비스 관리자, 로거, 네트워크 매니저** 등 게임 전역에서 공유되는 서비스에 주로 사용된다. 위 예제에선 하나의 `EquipmentManager`와 `StatManager`가 있다고했으므로, `Lifetime.Singletone` 을 사용했다. 가장 흔히 사용되는 타입으로 만약 이 객체가 상태를 갖고 있는 경우, 여러 컴포넌트에서 동시에 접근할 수 있으므로 동기화에 유의해야 한다.
>
> ### 🔸 `Lifetime.Transient`
> 
> *일시적*이라는 뜻을 가진 [Transient](https://en.dict.naver.com/#/entry/enko/7d1edac6f3aa4cfa8ef7fd229e8b503b)라는 단어에서 알 수 있듯이, 요청이 있을 때 마다 새로운 인스턴스를 만든다. 주로 상태를 갖지 않거나 짧은 시간동안만 사용되는 객체에 쓰이며, 무거운 리소스가 없고 객체를 재사용하지 않을 때 사용하면 좋다. 주의사항으로는 자주 생성되므로 GC에 부담이 갈 수 있다.
>
> ### 🔸 `Lifetime.Scoped`
> 
> 현재 `LifetimeScope` 내에서 **한 번만 생성** 되며, 같은 Scope 내에서는 **같은 인스턴스가 공유**된다. 달리 말하면, 서로 다른 Scope에서 요청을 하면 서로 다른 인스턴스가 생성된다는 뜻이다. 특정 범위 내에서 '만' 인스턴스를 공유하므로, Scene, UI Window, 전투 시스템 등 스코프 단위로 상태나 리소스를 관리해야 할 때 유용하다. 예를 들어, 씬마다 다른 GameManager나 UIController를 사용할 경우 적합하다. 이런 특징 때문에 Scope 간 관계를 명확히 인지하고 사용해야 한다!

모든 준비를 다 마쳤으면, 다음과 같이 빈 GameObject에 `LifetimeScope` 컴포넌트를 추가한다.

<center>
<img src="{{img_url}}/img_09.png" style="max-width:586px; width:100%; margin-top:-30px;">
<figcaption style="margin-top:-30px;">LifetimeScope 컴포넌트 추가</figcaption>
</center>

이렇게 두면, `VContainer`가 `StatManager` 객체에게 `EquipmentManager` 객체를 주입하게된다. 

근데, 막상 에디터의 플레이 버튼을 눌러보면 이 상태에서는 아무런 동작도 하지 않는다. 당연하게도, `EquipmentManager`와 `StatManager`의 어떤 메서드나 필드도 *(Unity의 라이프사이클과 관련이 있는)* MonoBehaviour 클래스에서 호출되지 않기 때문이다. 이런 상태라면 주입이 됐는지 안됐는지 알 길이 딱히 없다.

<center>
<img src="{{img_url}}/img_12.png" style="max-width:320px; width:100%; margin-top:-30px;">
<figcaption style="margin-top:-30px;">이해를돕기위 &nbsp;&nbsp; 한저에 &nbsp;&nbsp; 상상도</figcaption>
</center>

우리는 Unity에서 VContainer를 사용 할 것이기 때문에, Unity Lifecycle과의 연동이 필요하고, VContainer에서도 이를 잘 알기 때문에 MonoBehaviour 클래스를 상속받지 않은 일반 C# 클래스도 Unity Lifecycle과 연동 될 수 있도록 여러가지 인터페이스를 제공하고 있다. 자세한 내용은 다음과 같다.

| **VContainer entry point** |	**Timing** |
|:---:|:---|
| `IInitializable.Initialize()` | 	Immediately after building the container |
| `IPostInitializable.PostInitialize()` | `IInitializable.Initialize()` 이후 |
| `IStartable.Start()` | `MonoBehaviour.Start()` 와 비슷한 시기 |
| `IAsyncStartable.StartAsync()` | `MonoBehaviour.Start()` 와 비슷한 시기 (비동기) |
| `IPostStartable.PostStart()` | `MonoBehaviour.Start()` 이후 |
| `IFixedTickable.FixedTick()` | `MonoBehaviour.FixedUpdate()` 와 비슷한 시기 |
| `IPostFixedTickable.PostFixedTick()` | `MonoBehaviour.FixedUpdate()` 이후 |
| `ITickable.Tick()` | `MonoBehaviour.Update()` 와 비슷한 시기 |
| `IPostTickable.PostTick()` | `MonoBehaviour.Update()` 이후 |
| `ILateTickable.LateTick()` | `MonoBehaviour.LateUpdate()` 와 비슷한 시기 |
| `IPostLateTickable.PostLateTick()` | `MonoBehaviour.LateUpdate()` 이후 |

<div style="padding:10px 10px 10px 30px; border-radius:8px; background-color:#f2f2f2; margin-bottom:30px">
<details style="transition:1s">
<summary style="font-size:16px">
<b style="cursor:pointer">&nbsp; 🔎 Unity & VContainer Order of Execution</b>
</summary>
<div style="color:#a2a2a2">
<hr style="border:1px solid #666666">
<center>
<img src="{{img_url}}/img_13.png" style="max-width:618px; width:100%; margin-top:-30px;">
<figcaption style="margin-top:-30px;">Order of Execution</figcaption>
</center>
</div>
</details>
</div>

``` cs
public class StatManager : ITickable
{
    private IEquipmentManager _equipmentManager;
    private float _characterAttackPower = 100f;

    public StatManager(IEquipmentManager equipmentManager)
    {
        _equipmentManager = equipmentManager;
    }

    public float GetTotalAttackPower()
    {
        return _characterAttackPower +
            _equipmentManager.GetAttackPower();
    }

    void ITickable.Tick()
    {
        var totalAttackPower = GetTotalAttackPower();
        Debug.Log($"<color=oragne>캐릭터 Stat : {totalAttackPower}</color>");
    }
}
```

<center>
<img src="{{img_url}}/img_10.png" style="max-width:444px; width:100%; margin-top:-30px;">
<figcaption style="margin-top:-30px;">ITickable 인터페이스 구현하고, EntryPoint를 추가했을 때 모습</figcaption>
</center>

---