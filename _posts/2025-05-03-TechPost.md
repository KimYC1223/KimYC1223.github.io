---
layout: post
pagination: 
  enabled: true
type: tech
date: 2025-05-03 17:21
category: Blog
title: "[VContainer] Unity와 Dependency Injection"
subtitle: "Unity의 의존성 주입(DI)과 VContainer 에셋 소개"
writer: KimYC1223
post-header: false
image: title.gif
tags: [JobPreparation]
draft : false
---

{% capture img_url %}/assets/blog/{{page.date | date: "%Y-%m-%d"}}-TechPost{% endcapture %}

<span class="post-h1">&nbsp;1&nbsp;&nbsp;|&nbsp;&nbsp;개요&nbsp;</span>

이번에 이직하게된 [DEVSISTERS의 채용공고](/blog/2025/05/01/TechPost)를 보니, 팀에서 <span class="post-highlight">VContainer</span>라는 플러그인을 사용하는 것 같았다. 물론 공고에 따르면 입사 후 배워 나갈 수 있는 것으로 보였지만, 그래도 미리 공부를 해두면 배울 때 훨씬 빠르게 배울 수 있을 것 같아서, 정리를 해보고자 한다.

<center>
<img src="{{img_url}}/img_00.png" style="max-width:450px; width:100%; border:1px solid #000000;">
<figcaption style="margin-top:-30px;">STUDIO KINGDOM 채용 공고중 일부</figcaption>
</center>

먼저 의존성 주입이란 무엇인지 알아보고, Unity에서 이를 지원하기 위한 3rd 파티 플러그인인 VContainer에 대해 알아보도록 한다.

<br>

----

<span class="post-h1">&nbsp;2&nbsp;&nbsp;|&nbsp;&nbsp;C#과 의존성 주입 (Dependency Injection)&nbsp;</span>

## 🔷 2-1. 의존성 주입이란?

<span class="post-highlight">의존성 주입(Dependency Injection)</span>은 클래스가 필요한 의존 객체를 외부로부터 전달받는 설계 방식이다. 이름은 굉장히 어렵게 들리지만, 개념 자체는 단순하다. 객체 내부에서 직접 다른 객체를 생성하지 않고, 필요한 것을 외부에서 `주입받는다` 는 점이 핵심이다.

이해를 돕기위해, 코드를 살펴보도록 하자. 아래 코드는 의존성 주입이 적용되지 않은 일반적인 C#코드의 한 예이다. 게임 전반을 관리하는 매니저 클래스인 `GameManager` 와, 외부와 연결된 `GameServer`가 있다. 먼저, `GameServer`는 아래와 같다.

``` cs
public class GameManager
{
    // 멤버 변수
    private GameServer gameServer;
    private int score;

    // 생성자
    public Player()
    {
        gameServer = new GameServer(); // 직접 생성
    }

    // 점수 저장 메서드
    public void SaveScore()
    {
        gameServer.SaveData(score);
    }
}
```

`GameServer` 클래스는 다음과 같다고 하자.

``` cs
public class GameServer
{
    public void SaveData(int score)
    {
        Console.WriteLine($"저장된 점수 : ${score}");
    }
}
```

`GameManager`와 `GameServer`는 서로 <span class="post-highlight">Composition(구성)</span>관계임을 알 수 있다. 이를 UML 클래스 다이어그램으로 표현하면 다음과 같다.

> Composition(구성) 관계에 대해 잘 모른다면, [이전 블로그 게시글](/blog/2024/04/19/TechPost)의 `Relationships between classes` 부분을 참고하면 좋을 듯 하다.

<center>
<img src="{{img_url}}/img_01.png" style="max-width:527px; width:100%;">
<figcaption style="margin-top:-30px;">GameManager와 GameServer</figcaption>
</center>

이 방식의 문제는 <span class="post-highlight">GameManager가 GameServer의 구체적인 구현에 강하게 묶여 있다는 점</span>이다. 이는 다음과 같은 문제점을 유발 할 수 있다.

<br>

### 🔶 문제점 1. 테스트의 어려움

`GameManager` 를 테스트하기 위해 `GameServer` 를 그대로 사용할 경우, 실제 서버에 테스트 데이터가 저장될 위험이 있다. 따라서 테스트를 할 때에는 모의객체 *(Mock)* 를 써야할 것이다. 대충 `TestGameServer` 라는 이름으로 클래스를 만든 뒤, `GameManager` 생성자에서 `new GameServer()` 대신 `new TestGameServer()` 로 객체를 만들어 멤버 변수에 저장하게 될텐데, 문제는 테스트를 할 때 마다 이런식으로 `GameManager` 의 코드를 변경해주어야 한다는 것이다. 이는 휴먼에러가 생길 수 있는 큰 구멍으로, 코드의 안정성을 대폭 떨어트린다.

> 모의객체(Mock)를 잘 모른다면, [이전 블로그 게시글](/blog/2024/02/23/TechPost)의 `대역의 종류` 부분을 참고하면 좋을 듯 하다.

<br>

### 🔶 문제점 2. 낮은 확장성

개발이 진행되면서, `GameServer`를 `CloudGameServer` 따위로 교체할 필요가 생겼다고 하자. 이럴 경우 개발자가 `GameManager` 클래스의 코드를 변경해 주어야 할텐데, 이는 문제점 1번과 마찬가지로 코드의 확장성이 부족해지는 요인이 될 수 있다.

<br>

이런 문제들이 있다는것은 잘 알았다. **그런데 그럼 어떻게 바꿔야 하는가?** 여기서 사용되는 것이 바로 <span class="post-highlight">의존성 주입</span>이다! 일단, **구현** 된 객체를 의존하지 않도록, 새로운 인터페이스를 만들어준다.

아래는 새로 만든 `IGameServer` 인터페이스이다.

``` cs
public interface IGameServer
{
    void SaveData(int score);
}
```

그리고 `GameManager` 와 `GameServer` 모두 이 인터페이스를 참조하도록 코드를 변경해준다. 기존 `GameServer` 의 경우엔 인터페이스를 구현하도록 변경해주고, 

``` cs
public class GameServer : IGameServer
{
    public void SaveData(int score)
    {
        Console.WriteLine($"저장된 점수 : ${score}");
    }
}
```

그리고 `IGameServer` 라는 인터페이스가 생겼으니, 이를 구현하면 테스트용 모의객체도 쉽게 만들 수 있다. 예를 들면 다음과 같다.

``` cs
public class MockGameServer : IGameServer
{
    public bool WasSaveCalled { get; private set; } = false;

    public void SaveData(int score)
    {
        WasSaveCalled = true;
        Console.WriteLine($"[테스트용] 점수 저장됨: {score}");
    }
}
```

<br>

또한 `GameManager` 는 멤버 변수에서 구상클래스인 `GameServer` 를 자료형으로 두는게 아니라 `IGameServer` 를 두도록 변경한다. 즉, `GameManager` 에서 이를 직접 생성해서 사용하는 것이 아니라, 외부에서 주는 객체를 받아와서 저장하도록 만들어준다. 즉, 두 클래스를 **Composition** 관계에서 **Aggregation** 관계로 만들어 주도록 수정한다.

``` cs

public class GameManager
{
    // 멤버 변수
    private IGameServer gameServer;

    public GameManager(IGameServer server)
    {
        gameServer = server;
    }

    // 후략
}
```

이로써 `GameManager`는 생성될 때 변수로 어떤 인스턴스를 받느냐에따라 동작이 달라지게 된다. 기존과 다르게 `GameManager` 의 코드의 변경 없이 가능해 졌다는 점인데, 이는 `GameManager` 가 구상클래스에 의존성이 걸려있는 것이 아니라 인터페이스에 의존성이 걸리도록 변경했기 때문이다. UML 그림으로 보면 다음과 같다.

<center>
<img src="{{img_url}}/img_02.png" style="max-width:758px; width:100%;">
<figcaption style="margin-top:-30px;">DI를 적용한 버전</figcaption>
</center>