---
layout: post
pagination: 
  enabled: true
type: tech
date: 2025-05-03 17:21
category: Blog
title: "[VContainer] Unity와 Dependency Injection"
subtitle: "Unity의 의존성 주입(DI)과 VContainer 에셋 소개"
writer: KimYC1223
post-header: false
image: title.gif
tags: [JobPreparation]
draft : false
---

{% capture img_url %}/assets/blog/{{page.date | date: "%Y-%m-%d"}}-TechPost{% endcapture %}

<span class="post-h1">&nbsp;1&nbsp;&nbsp;|&nbsp;&nbsp;개요&nbsp;</span>

이번에 이직하게된 [DEVSISTERS의 채용공고](/blog/2025/05/01/TechPost)를 보니, 팀에서 <span class="post-highlight">VContainer</span>라는 플러그인을 사용하는 것 같았다. 물론 공고에 따르면 입사 후 배워 나갈 수 있는 것으로 보였지만, 그래도 미리 공부를 해두면 배울 때 훨씬 빠르게 배울 수 있을 것 같아서, 정리를 해보고자 한다.

<center>
<img src="{{img_url}}/img_00.png" style="max-width:450px; width:100%; border:1px solid #000000;">
<figcaption style="margin-top:-30px;">STUDIO KINGDOM 채용 공고중 일부</figcaption>
</center>

먼저 의존성 주입이란 무엇인지 알아보고, Unity에서 이를 지원하기 위한 3rd 파티 플러그인인 VContainer에 대해 알아보도록 한다.

<br>

----

<span class="post-h1">&nbsp;2&nbsp;&nbsp;|&nbsp;&nbsp;C#과 의존성 주입 (Dependency Injection)&nbsp;</span>

## 🔷 2-1. 의존성 주입이란?

<span class="post-highlight">의존성 주입(Dependency Injection)</span>은 클래스가 필요한 의존 객체를 외부로부터 전달받는 설계 방식이다. 이름은 굉장히 어렵게 들리지만, 개념 자체는 단순하다. 객체 내부에서 직접 다른 객체를 생성하지 않고, 필요한 것을 외부에서 `주입받는다` 는 점이 핵심이다.

이해를 돕기위해, 코드를 살펴보도록 하자. 아래 코드는 의존성 주입이 적용되지 않은 일반적인 C#코드의 한 예이다. 게임 전반을 관리하는 매니저 클래스인 `GameManager` 와, 외부와 연결된 `GameServer`가 있다. 

먼저, `GameManager`는 아래와 같다.

``` cs
public class GameManager
{
    // 멤버 변수
    private GameServer gameServer;
    private int score;

    // 생성자
    public Player()
    {
        gameServer = new GameServer(); // 직접 생성
    }

    // 점수 저장 메서드
    public void SaveScore()
    {
        gameServer.SaveData(score);
    }
}
```

`GameServer` 클래스는 다음과 같다고 하자.

``` cs
public class GameServer
{
    public void SaveData(int score)
    {
        // =======================================
        //  서버 통신용 코드
        // =======================================

        Console.WriteLine($"저장된 점수 : ${score}");
    }
}
```

`GameManager`와 `GameServer`는 서로 <span class="post-highlight">Composition(구성)</span>관계임을 알 수 있다. 이를 UML 클래스 다이어그램으로 표현하면 다음과 같다.

> Composition(구성) 관계에 대해 잘 모른다면, [이전 블로그 게시글](/blog/2024/04/19/TechPost)의 `Relationships between classes` 부분을 참고하면 좋을 듯 하다.

<center>
<img src="{{img_url}}/img_01.png" style="max-width:527px; width:100%;">
<figcaption style="margin-top:-30px;">GameManager와 GameServer <i><b>(그림 A)</b></i></figcaption>
</center>

이 방식의 문제는 <span class="post-highlight">GameManager가 GameServer의 구체적인 구현에 강하게 묶여 있다는 점</span>이다. 이는 다음과 같은 문제점을 유발 할 수 있다.

<br>

### 🔶 문제점 1. 테스트의 어려움

`GameManager` 를 테스트하기 위해 `GameServer` 를 사용할 경우, 실제 서버에 테스트 데이터가 저장될 위험이 있기 때문에, 테스트를 할 때에는 모의객체 *(Mock)* 를 써야할 것이다. 따라서 테스트용 모의객체 클래스 `TestGameServer` 를 만든 뒤, `GameManager` 생성자에서 `new GameServer()` 대신 `new TestGameServer()` 로 객체를 만들도록 `코드를 수정하여`  멤버 변수에 저장해야 한다. 그러나 이는 곧 테스트를 할 때 마다 이런식으로 `GameManager` 의 코드를 변경해주어야 한다는 뜻인데 이런식의 코드 변경은 휴먼에러가 생길 수 있는 큰 구멍으로, 코드의 안정성을 대폭 떨어트린다.

> 모의객체(Mock)를 잘 모른다면, [이전 블로그 게시글](/blog/2024/02/23/TechPost)의 `대역의 종류` 부분을 참고하면 좋을 듯 하다.

<br>

### 🔶 문제점 2. 낮은 확장성

개발이 진행되면서, `GameServer`를 `CloudGameServer` 따위로 교체할 필요가 생겼다고 하자. 이럴 경우 개발자가 `GameManager` 클래스의 코드를 변경해 주어야 할텐데, 이는 문제점 1번과 마찬가지로 코드의 확장성이 부족해지는 요인이 될 수 있다.

<br>

이런 문제들이 있다는것은 잘 알았다. **그런데 그럼 어떻게 바꿔야 하는가?** 일단, **구현** 된 객체를 의존하지 않도록, 새로운 인터페이스를 만들어준다.

아래는 새로 만든 `IGameServer` 인터페이스이다.

``` cs
public interface IGameServer
{
    void SaveData(int score);
}
```

그리고 `IGameServer` 라는 인터페이스가 생겼으니, 인터페이스를 구현하도록 기존 `GameServer` 를 변경해준다.

``` cs
public class GameServer : IGameServer  // IGameServer 구현
{
    public void SaveData(int score)
    {
        // =======================================
        //  서버 통신용 코드
        // =======================================

        Console.WriteLine($"저장된 점수 : ${score}");
    }
}
```

이 인터페이스를 구현하면 테스트용 모의객체도 쉽게 만들 수 있다. 예를 들면 다음과 같다.

``` cs
public class MockGameServer : IGameServer
{
    public bool WasSaveCalled { get; private set; } = false;

    public void SaveData(int score)
    {
        WasSaveCalled = true;
        Console.WriteLine($"[테스트용] 저장된 점수: {score}");
    }
}
```

<br>

또한 `GameManager` 의 멤버 변수를 구상클래스인 `GameServer` 를 자료형으로 두는게 아니라 `IGameServer` 를 자료형으로 두도록 변경한다. 그 후 `GameManager` 에서 이를 직접 생성해서 사용하는 것이 아니라 **외부에서 주는 객체를 받아와서 저장하도록** 만들어준다. 즉, 두 클래스를 **Composition** 관계에서 **Aggregation** 관계로 만들어 주도록 수정한다.

``` cs
public class GameManager
{
    // 멤버 변수 ( IGameServer 인터페이스 사용 )
    private IGameServer gameServer;

    // 생성자에서 받아와서 멤버 변수에 저장하도록 변경 ( Aggregation관계가 되도록 )
    public GameManager(IGameServer server)
    {
        gameServer = server;
    }

    // 후략
}
```

이로써 `GameManager`는 생성될 때 변수로 어떤 인스턴스를 받느냐에따라 동작이 달라지게 된다. 기존과 다르게 `GameManager` 의 코드의 변경 없이 가능해 졌다는 점이다.

즉, 다양한 상황에 따라 다른 구현을 유연하게 주입할 수 있다. 예를 들어 테스트에서는 다음과 같이 가짜 객체를 전달할 수 있다.

``` cs
var mockGameServer = new MockGameServer();
var manager = new GameManager(server : mockGameServer);
```

이것이 바로 <span class="post-highlight">의존성 주입</span>이다!

**`의존성 주입(Dependency Injection / DI)` 은 객체가 직접 필요한 의존성을 생성하는 것이 아니라, 외부에서 전달받는 방식이다.** 이를 통해 객체 간의 결합도를 낮추고, 보다 유연하고 확장 가능한 구조를 만들 수 있다. 특히 테스트 코드 작성 시, 실제 서버 대신 테스트용 객체를 주입할 수 있어 테스트의 정확성과 효율성이 향상된다. 또한 새로운 기능을 추가하거나 기존 로직을 수정할 때도 최소한의 변경으로 적용이 가능하다는 장점이 있다. 결국 이는 유지보수성과 코드의 품질을 높이는 데 매우 중요한 역할을 한다.

개념적으로는 **`레고 블록`** 에 비유할 수 있다. 조립식 블록처럼, 각 구성 요소를 갈아 끼우는 것이 쉬워진다. 하나의 블록(클래스)이 다른 블록에 결합될 때, 직접 붙이는 것이 아니라 외부에서 알맞게 연결해주는 셈이다.

이러한 유연성이 생기는 이유는 `GameManager` 가 구상클래스에 의존성이 걸려있는 것이 아니라 인터페이스에 의존성이 걸리도록 변경했기 때문이다. UML 그림으로 보면 다음과 같다.

<center>
<img src="{{img_url}}/img_02.png" style="max-width:758px; width:100%;">
<figcaption style="margin-top:-30px;">DI를 적용한 버전 <i><b>(그림 B)</b></i></figcaption>
</center>

자세히 보면 포스트의 첫번째 UML <i><b>(그림 A)</b></i> 과 이번 UML <i><b>(그림 B)</b></i> 에서 `화살표의 방향` 이 조금 달라진 것을 볼 수 있다. 첫번째 에서는 한 방향 *(왼쪽에서 오른쪽으로 향함)* 이었는데, 이번 UML 에서는 클래스 사이에 인터페이스가 생기고, 두 방향으로 된 것을 볼 수 있다. *(양쪽에서 가운데로 향함)* 이를 제어의 역전, <span class="post-highlight">Inversion Of Control</span> 이라고 한다.

<center>
<img src="{{img_url}}/img_03.png" style="max-width:285px; width:100%; padding:10px;">
<figcaption style="margin-top:-30px;">제어의 역전 / IOC(Inversion Of Control)</figcaption>
</center>

<br>

#### 📚 참고 문서

* <b>[ 5분 개발지식 유튜브 ]</b> : <a href="https://velog.io/@kwontae1313/%EC%A0%9C%EC%96%B4-%EC%97%AD%EC%A0%84IoC%EA%B3%BC-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85DI" class="post-no-highlight-link">의존성 주입 3분만에 이해하기 (Dependency Injection, Inversion of Control)</a>
* <b>[ dev.KwonTaeHyeong 블로그 ]</b> : <a href="https://www.youtube.com/watch?v=1vdeIL2iCcM" class="post-no-highlight-link"> 제어의 역전(IoC)</a>

<br>

---

## 🔷 2-2. IoC Container

다시 코드를 살펴보자.

``` cs
public class GameManager
{
    // 멤버 변수 ( IGameServer 인터페이스 사용 )
    private IGameServer gameServer;

    // 생성자에서 받아와서 멤버 변수에 저장하도록 변경
    public GameManager(IGameServer server)
    {
        gameServer = server;
    }

    // 후략
}
```

앞서 설명한대로, 구상클래스의 의존성을 낮추기 위해 `gameServer` 필드에 객체를 할당할 때 직접 `new ()` 로 객체를 만들지 않도록 했다. 대신 생성자에서 `IGameServer` 인터페이스를 구현한 인스턴스를 받아오도록 변경했다. 

이로써 `GameManager` 클래스는 `GameServer` 라는 구상클래스를 모르게 됐지만, 대신 다른 곳에서 `GameServer` 인스턴스를 만들어서 `GameManager` 생성자에게 전달해 주어야만 하게되었다. 이렇게 인스턴스를 만들어서 다른 클래스에게 할당해주는 클래스를 <span class="post-highlight">IoC Container</span> 라고 한다.

예를 들면 다음과 같다.

``` cs
public class Program
{
    static void Main(string[] args)
    {
        var iocContainer = new IoCContainer();
        var gameManager = iocContainer.CreateGameManager();

        gameManager.SaveScore();
    }
}

public class IoCContainer
{
    public GameManager CreateGameManager()
    {
        return new GameManager(server : new GameServer());
    }
}
```

일반적으로 생각해보면 다른 클래스를 사용하려는 곳에서 객체를 결정/생성하고 그 객체의 메서드를 호출하는 방식이 자연스러울 수 있다. `Program` 클래스가 `GameManager` 를 생성하고, 그 `GameManager` 에서 `GameServer` 를 생성하는 식이다. <span class="post-highlight">제어의 역전 (Inversion of Control)</span> 이란 이러한 제어의 흐름을 역전하는 것을 의미한다.

<center>
<img src="{{img_url}}/img_04.png" style="max-width:662px; width:100%;">
<figcaption style="margin-top:-30px;">기존 방식을 나타내는 UML</figcaption>
</center>

**IoC** 가 적용된다면 `IoCContainer` 가 *(때로는 DependencyInject 라고도 부른다.)* 그러한 업무를 모두 담당하게 된다. 필요한 객체를 생성하고, 관계에 맞게 전달하여 각 클래스간의 의존성을 낮춰주게 된다.

<center>
<img src="{{img_url}}/img_05.png" style="max-width:615px; width:100%;">
<figcaption style="margin-top:-30px;">IoC가 적용된 UML</figcaption>
</center>

가끔 IoC Container를 Factory Pattern과 혼동하여 IoC 관련 라이브러리를 그냥 Factory처럼 사용하는 경우도 많이 보았는데, Factory는 단순히 object를 생성하는 assembler에 가깝고 IoC Container는 거기에 제어의 역전 개념이 적용되어야 한다. IoC Container를 그냥 사용한다고 제어가 역전 되는 게 아니다.

<br>

#### 📚 참고 문서

* <b>[ Develogs 블로그 ]</b> : <a href="https://develogs.tistory.com/19" class="post-no-highlight-link"> 제어의 역전(Inversion of Control, IoC) 이란?</a>

<br>

---

## 🔷 2-3. Unity와 Dependency Injection

C#에서는 DI가 비교적 자연스럽게 적용되지만, **Unity에서는 몇 가지 구조적인 제약 때문에 DI를 도입하는 데 어려움이 있다.** `MonoBehaviour` 기반 구조, 생명주기 관리, GameObject 종속성 등이 복합적으로 작용하며 일반적인 DI 방식과 충돌한다.

<center>
<img src="{{img_url}}/img_06.gif" style="max-width:253px; width:100%; margin-top:-30px;">
<figcaption style="margin-top:-30px;">어림도없지! 바로 쓸 수 없다!</figcaption>
</center>

 대표적인 예로, `MonoBehaviour` 를 상속받은 클래스를 새롭게 추가하려고 하는 경우를 생각해보자. 문제는 `MonoBehaviour` 는 우리가 직접 `new ()` 키워드로 인스턴스 생성을 할 수 없고, 반드시 GameObject에 붙여야만 한다는 점이다.
 
``` cs
var player = new Player(); // 컴파일은 되지만 제대로 작동하지 않음
```
 
위와 같은 코드는 컴파일은 정상적으로 되지만, 다음과 같은 에러가 뜨는것을 볼수있다. 

<center>
<img src="{{img_url}}/img_07.png" style="max-width:256px; width:100%; margin-top:-30px;">
<figcaption style="margin-top:-30px;">new 키워드로 MonoBehaviour 클래스를 생성하면 발생하는 오류</figcaption>
</center>

<div style="padding:10px 10px 10px 30px; border-radius:8px; background-color:#f2f2f2; margin-bottom:30px">
<details style="transition:1s">
<summary style="font-size:18px">
<b style="cursor:pointer">&nbsp; 🔎 Why can't create MonoBehaviour with “new’ keyword?</b>
</summary>
<div style="color:#a2a2a2">
<hr style="border:1px solid #666666">
<p><i>MonoBehaviours are Components. This means they are inextricably attached to GameObjects at all times. If you create a MonoBehaviour with new, then obviously it is not attached to a GameObject. It cannot exist in this state, so Unity gives you a warning that this is bad. ... MonoBehaviours are meant to only exist when they are attached to GameObjects. You can create one by Instantiating an existing one (such as from a prefab), or by using the AddComponent method on GameObject.</i></p>
<p style="color:#666666">MonoBehaviour는 컴포넌트입니다. 즉, 항상 게임 오브젝트에 불가분의 관계로 연결되어 있습니다. new를 사용하여 MonoBehaviour를 생성하면 게임 오브젝트에 연결되지 않습니다. 이 상태로는 존재할 수 없으므로 Unity는 이러한 상태가 좋지 않다는 경고를 표시합니다. ... MonoBehaviour는 게임 오브젝트에 연결될 때만 존재합니다. 기존 MonoBehaviour를 인스턴스화하거나(예: 프리팹에서) GameObject의 AddComponent 메서드를 사용하여 MonoBehaviour를 생성할 수 있습니다.</p>
</div>
</details>
</div>

또한 Unity는 `MonoBehaviour` 의 생성자를 호출하지 않기 때문에, <span class="post-highlight">생성자 주입(Constructor Injection)</span>이 불가능하다. 의존성 주입의 가장 일반적인 방식이 막혀 있는 셈이다.

``` cs
public class Player : MonoBehaviour
{
    private readonly IGun _gun; // 컴파일 에러

    public Player(IGun gun) { ... } // 호출되지 않음
}
```

대신 Unity에서는 대부분 `Start()`, `Awake()` 같은 생명주기 메서드에서 의존 객체를 초기화하지만, 이 역시 명시적인 주입보다는 `Find(...)`나 `GetComponent(...)` 등으로 직접 의존성을 해결하는 방식이 많다. **이 방식은 외부에서 객체 간 의존 관계를 제어하기 어렵게 만든다.**

<br>

#### 📚 참고 문서

* <b>[ Unity 공식 문서 ]</b> : <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.html" class="post-no-highlight-link">MonoBehaviour</a>
* <b>[ Unity 포럼 ]</b> : <a href="https://discussions.unity.com/t/cannot-create-monobehaviour-with-new-keyword/858172" class="post-no-highlight-link">Cannot create MonoBehaviour with “new’ keyword?</a>
* <b>[ 나의 삽질일지 블로그 ]</b> : <a href="https://prhymery.github.io/docs/Unity/MonoBehaviour/" class="post-no-highlight-link"> MonoBehaviour</a>

<br>
