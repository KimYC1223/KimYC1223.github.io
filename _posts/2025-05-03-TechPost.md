---
layout: post
pagination: 
  enabled: true
type: tech
date: 2025-05-03 17:21
category: Blog
title: "[VContainer] Unity와 Dependency Injection"
subtitle: "Unity의 의존성 주입(DI)과 VContainer 에셋 소개"
writer: KimYC1223
post-header: false
image: title.gif
tags: [JobPreparation]
draft : false
---

{% capture img_url %}/assets/blog/{{page.date | date: "%Y-%m-%d"}}-TechPost{% endcapture %}

<span class="post-h1">&nbsp;1&nbsp;&nbsp;|&nbsp;&nbsp;개요&nbsp;</span>

이번에 이직하게된 [DEVSISTERS의 채용공고](/blog/2025/05/01/TechPost)를 보니, 팀에서 <span class="post-highlight">VContainer</span>라는 플러그인을 사용하는 것 같았다. 물론 공고에 따르면 입사 후 배워 나갈 수 있는 것으로 보였지만, 그래도 미리 공부를 해두면 배울 때 훨씬 빠르게 배울 수 있을 것 같아서, 정리를 해보고자 한다.

<center>
<img src="{{img_url}}/img_00.png" style="max-width:450px; width:100%; border:1px solid #000000;">
<figcaption style="margin-top:-30px;">STUDIO KINGDOM 채용 공고중 일부</figcaption>
</center>

먼저 의존성 주입이란 무엇인지 알아보고, Unity에서 이를 지원하기 위한 3rd 파티 플러그인인 VContainer에 대해 알아보도록 한다.

<br>

----

<span class="post-h1">&nbsp;2&nbsp;&nbsp;|&nbsp;&nbsp;C#과 의존성 주입 (Dependency Injection)&nbsp;</span>

## 🔷 2-1. 의존성 주입이란?

<span class="post-highlight">의존성 주입(Dependency Injection)</span>은 클래스가 필요한 의존 객체를 외부로부터 전달받는 설계 방식이다. 이름은 굉장히 어렵게 들리지만, 개념 자체는 단순하다. 객체 내부에서 직접 다른 객체를 생성하지 않고, 필요한 것을 외부에서 `주입받는다` 는 점이 핵심이다.

이해를 돕기위해, 코드를 살펴보도록 하자. 아래 코드는 의존성 주입이 적용되지 않은 일반적인 C#코드의 한 예이다.

``` cs
public class GameManager
{
    // 멤버 변수
    private GameServer gameServer;

    // 생성자
    public Player()
    {
        gameServer = new(); // 직접 생성
    }

    // 점수 저장 메서드
    public void SaveScore()
    {
        gameServer.Save();
    }
}
```

`GameServer` 클래스는 다음과 같다고 하자.

``` cs
public class GameServer
{
    public Save()
    {
        Console.WriteLine("");
    }
}
```

이 방식의 문제는 <span class="post-highlight">GameManager가 GameServer의 구체적인 구현에 강하게 묶여 있다는 점</span>이다. 이게 무슨 소리일까? 다음 예시를 통해 어떤 문제 점이 있는지 확인해보자.
