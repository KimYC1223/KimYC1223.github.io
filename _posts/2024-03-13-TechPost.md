---
layout: post
pagination: 
  enabled: true
type: tech
date: 2024-03-13 06:44
category: Blog
title: ì½”ë”©í…ŒìŠ¤íŠ¸ ì´ë¡  ê³µë¶€ 2í¸
subtitle: ì½”ë”©í…ŒìŠ¤íŠ¸ ì¤€ë¹„ë¥¼ ìœ„í•œ ì•Œê³ ë¦¬ì¦˜ ë° ìë£Œêµ¬ì¡° ê°œìš”
writer: KimYC1223
post-header: false
image: title.png
tags: [JobPreparation]
draft : false
---

{% capture img_url %}/assets/blog/{{page.date | date: "%Y-%m-%d"}}-TechPost{% endcapture %}

ì‹¤ì œ ì½”ë”©í…ŒìŠ¤íŠ¸ì—ì„œ ì¨ë¨¹ìœ¼ë ¤ê³  ë¯¸ë¦¬ ì •ë¦¬í•´ë‘” í¬ìŠ¤íŠ¸

ì§€ë‚œë²ˆ [ì½”ë”©í…ŒìŠ¤íŠ¸ ì´ë¡  ê³µë¶€ 1í¸](https://kimyc1223.github.io/blog/2022/03/01/TechPost.html)ì—ì„œ,

ì•Œê³ ë¦¬ì¦˜ íŒŒíŠ¸ê°€ ë„ˆë¬´ ê¸¸ì–´ì ¸ ì´ë ‡ê²Œ 2í¸ìœ¼ë¡œ ë¶„ë¦¬í–ˆë‹¤.

ë¬´ë ¤ 2ë…„ë§Œì˜... ì¬í¬ìŠ¤íŒ…!

ê·¸ëŸ¼ ì‹œì‘í•´ë³´ì

---

# ğŸ­ ìì£¼ ì‚¬ìš©í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ ê°„ë‹¨ ì •ë¦¬

## ğŸ”¶ I. íƒìƒ‰ ë° ì •ë ¬

### ğŸ’  Sort

STLì˜ sortëŠ” quick sort(í€µ ì •ë ¬)ì„ ê¸°ë°˜ìœ¼ë¡œ í•¨ìˆ˜ê°€ êµ¬í˜„ë˜ì–´ìˆì–´, í‰ê·  ì‹œê°„ë³µì¡ë„ëŠ” n log n ì´ë‹¤.

<br>

``` cpp
#include<iostream>
#include<algorithm>

int arr[10] = {3, 7, 2, 4, 1, 0, 9, 8, 5, 6};

sort(v.begin(), v.end(), greater<int>());
// 9, 8, 7, 6, 5, 4, 3, 2, 1, 0
```

| í•¨ìˆ˜ | ì„¤ëª… |
|:---:|:---|
| `sort(arr, arr+n)` | 0 ~ nê¹Œì§€ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬ |
| `sort(v.begin(), v.end())` | ì²˜ìŒë¶€í„° ëê°€ì§€ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬ | 
| `sort(v.begin(), v.end(), compare)` | ì‚¬ìš©ì ì •ì˜ í•¨ìˆ˜ ì‚¬ìš©í•´ì„œ ì •ë ¬ |
| `sort(v.begin(), v.end(), greater<ìë£Œí˜•>())` | ë‚´ë¦¼ì°¨ìˆœ (Descending order) ì •ë ¬ |
| `sort(v.begin(), v.end(), less<ìë£Œí˜•>())` | ì˜¤ë¦„ì°¨ìˆœ (Ascending order) ì •ë ¬ |

<br>

---

### ğŸ’  Binary Serach

ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬ëœ ë¦¬ìŠ¤íŠ¸ì—ì„œ íŠ¹ì •í•œ ìœ„ì¹˜ë¥¼ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜

<ul>
    <li><span style="color:red; font-weight:bold;">ì •ë ¬ëœ ë¦¬ìŠ¤íŠ¸ì—ì„œë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ</span></li>
    <li>ê²€ìƒ‰í•  ë–„ë§ˆë‹¤ ì„ í˜•íƒìƒ‰ê³¼ëŠ” ë¹„êµí•  ìˆ˜ ì—†ëŠ” ì†ë„ : <b>log_2 N</b></li>
</ul>

``` cpp
binary_search(arr.begin(), arr.end(), ì°¾ìœ¼ë ¤ëŠ”ê°’)      // ìˆìœ¼ë©´ true, ì—†ìœ¼ë©´ false
```

<br>

ì•„ë˜ëŠ” ì´ì§„íƒìƒ‰ì„ ì§ì ‘ êµ¬í˜„í•œ ì½”ë“œ. STLì—ì„œëŠ” `bool`ì´ì§€ë§Œ, ë‚´ê°€ ì˜ ì“°ë ¤ê³  `int`ë¡œ ë°”ê¿¨ë‹¤.

``` cpp
// ëª»ì°¾ì•˜ìœ¼ë©´ -1 ë¦¬í„´, ì°¾ì•˜ìœ¼ë©´ indexê°’ ë¦¬í„´
int binary_search(vector<int>& arr, int len, int target){
    int low = 0, high = len - 1;
    
    while(low <= high){
        int mid = (low + high) / 2;
        
        //ì›í•˜ëŠ” ê°’ì„ ì°¾ì•˜ë‹¤ë©´ true ë°˜í™˜
        if(target == arr[mid])    return true;
        
        // ì›í•˜ëŠ” ê°’ì´ ë” ì‘ë‹¤ë©´ ê²€ì‚¬ ë²”ìœ„ë¥¼ ë” ë‚®ê²Œ ì¡ì•„ì•¼ í•œë‹¤.
        if(target < arr[mid]){
            high = mid - 1;
        }
        // ì›í•˜ëŠ” ê°’ì´ ë” í¬ë‹¤ë©´ ê²€ì‚¬ ë²”ìœ„ë¥¼ ë” í¬ê²Œ ì¡ì•„ì•¼ í•œë‹¤.
        else if(target > arr[mid]){
            low = mid + 1;
        }
    }
    return false; // ë§ˆì§€ë§‰ê¹Œì§€ ëª»ì°¾ëŠ”ë‹¤ë©´ false ë°˜í™˜
}
```

<details><summary>ì¬ê·€í•¨ìˆ˜ë¡œë„ êµ¬í˜„ ê°€ëŠ¥</summary>
<div class="highlight"><pre class="syntax"><code><span class="kt">int</span> <span class="nf">binary_search</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">low</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span>    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span><br><br>    <span class="k">if</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span>    <span class="k">return</span> <span class="n">mid</span><span class="p">;</span><br><br>    <span class="c1">// ì°¾ëŠ” ìˆ˜ê°€ ë” ì‘ë‹¤ë©´, ê²€ì‚¬ ë²”ìœ„ë¥¼ ë” ì‘ê²Œ ì¡ì•„ì•¼ í•œë‹¤.</span>
    <span class="k">if</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">binary_search</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span><br><br>    <span class="c1">// ì°¾ëŠ” ìˆ˜ê°€ ë” í¬ê°€ë©´, ê²€ì‚¬ ë²”ìœ„ë¥¼ ë” í¬ê²Œ ì¡ì•„ì•¼ í•œë‹¤.</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">binary_search</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
</details><br>

> ì½”ë“œ ì¶œì € : [[C++ Algorithm] ì´ë¶„ íƒìƒ‰(Binary Search)](https://m42-orion.tistory.com/69)

<br>

---

### ğŸ’  Lower Boundì™€ Upper Bound

ì°¾ìœ¼ë ¤ëŠ” key ê°’ë³´ë‹¤ ê°™ê±°ë‚˜ í° ìˆ«ìê°€ ë°°ì—´ ëª‡ ë²ˆì§¸ì—ì„œ ì²˜ìŒ ë“±ì¥í•˜ëŠ”ì§€ ì°¾ëŠ” í•¨ìˆ˜

ë°˜ëŒ€ ìƒí™© *(ì°¾ìœ¼ë ¤ëŠ” keyê°’ì„ **ì´ˆê³¼**í•˜ëŠ” ìˆ«ìë¥¼ ì°¾ì„ ë•Œ)* ì—ì„œëŠ” `upper_bound`ì‚¬ìš©

<ul>
    <li><span style="color:red; font-weight:bold;">ì •ë ¬ëœ ë¦¬ìŠ¤íŠ¸ì—ì„œë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ</span></li>
    <li>ê²€ìƒ‰í•  ë–„ë§ˆë‹¤ ì„ í˜•íƒìƒ‰ê³¼ëŠ” ë¹„êµí•  ìˆ˜ ì—†ëŠ” ì†ë„ : <b>log_2 N</b></li>
</ul>

``` cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main() {

    vector<int> arr = { 1,2,3,4,5,6,6,6 };
    cout << "lower_bound(6) : " << lower_bound(arr.begin(), arr.end(), 6) - arr.begin();

    // ê²°ê³¼ -> lower_bound(6) : 5

    return 0;
}
```

> ì½”ë“œ ì¶œì € : [ì•Œê³ ë¦¬ì¦˜ - c++ lower_bound, upper_bound í™œìš©í•˜ê¸°](https://chanhuiseok.github.io/posts/algo-55/)

<br><br><br>

---

<br><br><br>

## ğŸ”¶ II. ê·¸ë˜í”„

[ê³µë¶€í•˜ëŠ” ì‹ë¹µë§˜](https://ansohxxn.github.io/algorithm/floyd/)ë‹˜ ë¸”ë¡œê·¸ì—ì„œ ì•„ì£¼ ì˜ ì •ë¦¬ëœ í‘œê°€ ìˆì–´ì„œ, ê°€ì ¸ì™”ë‹¤.

| **BFS** | **ë‹¤ìµìŠ¤íŠ¸ë¼** | **ë²¨ë§Œí¬ë“œ** | **í”Œë¡œì´ë“œ ì™€ìƒ¬** | 
|:---:|:---:|:---:|:---:|
| ê°€ì¤‘ì¹˜ê°€ ìˆëŠ” ê·¸ë˜í”„ âŒë¶ˆê°€ëŠ¥<br>*ê°€ì¤‘ì¹˜ê°€ ëª¨ë‘ ë™ì¼í•˜ê±°ë‚˜ ì—†ì–´ì•¼ í•œë‹¤.*<br> | ê°€ì¤‘ì¹˜ê°€ ëª¨ë‘ ë‹¤ë¥¸ ê·¸ë˜í”„ â­•ê°€ëŠ¥ | ê°€ì¤‘ì¹˜ê°€ ëª¨ë‘ ë‹¤ë¥¸ ê·¸ë˜í”„ â­•ê°€ëŠ¥ | ê°€ì¤‘ì¹˜ê°€ ëª¨ë‘ ë‹¤ë¥¸ ê·¸ë˜í”„ â­•ê°€ëŠ¥ |
| ê°€ì¤‘ì¹˜ ì—†ê³  ëª¨ë‘ ë™ì¼í•œ ì¤‘ìš”ë„ë¥¼ ê°€ì ¸ì•¼ í•¨ | ê°€ì¤‘ì¹˜ê°€ ì–‘ì˜ ì •ìˆ˜ì¼ ë•Œë§Œ ê°€ëŠ¥í•˜ë‹¤. | ê°€ì¤‘ì¹˜ê°€ ìŒì˜ ì •ìˆ˜ì¼ ë•Œë„ ê°€ëŠ¥í•˜ë‹¤. | ê°€ì¤‘ì¹˜ê°€ ìŒì˜ ì •ìˆ˜ì¼ ë•Œë„ ê°€ëŠ¥í•˜ë‹¤.<br>(ë‹¨, ìŒì˜ ì‚¬ì´í´ì´ ì—†ì–´ì•¼ í•œë‹¤.) | 
| í ì‚¬ìš© | ìš°ì„ ìˆœìœ„ í ì‚¬ìš© | Dynamic Programming ë°©ì‹<br> **distance[n] = min(distance[n], distance[m] + E(m, n))** |    Dynamic Programming ë°©ì‹<br>**distance[i,j] = min(distance[i,j], distance[i,n] + distance[n,j])** <Br>ì´ì°¨ì› ë°°ì—´(í–‰ë ¬) ì‚¬ìš© |
| `O(E)` | ìš°ì„ ìˆœìœ„ íë¥¼ ì‚¬ìš©í•  ê²½ìš° `O(ElogV)` | `O(VE)` | 3ì¤‘ forë¬¸ì„ ì‚¬ìš©í•˜ë¯€ë¡œ<br>`O(V^3)` |
| í•˜ë‚˜ì˜ íŠ¹ì • ì •ì ì—ì„œ ë‹¤ë¥¸ ì •ì ë“¤ê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•¨ `1:N` | í•˜ë‚˜ì˜ íŠ¹ì • ì •ì ì—ì„œ ë‹¤ë¥¸ ì •ì ë“¤ê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•¨ `1:N` | í•˜ë‚˜ì˜ íŠ¹ì • ì •ì ì—ì„œ ë‹¤ë¥¸ ì •ì ë“¤ê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•¨ `1:N` | ëª¨ë“  ì •ì ë“¤ê°„ì˜ ìŒì— ëŒ€í•´ ìµœë‹¨ ê²½ë¡œë¥¼ í•œë²ˆì— êµ¬í•¨ `N:N` |

<br>

---

### ğŸ’  Dijkstra

ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì€ ê·¸ë˜í”„ ìƒì—ì„œ ì‹œì‘ ì •ì ë¶€í„° ë‚˜ë¨¸ì§€ ê° ì •ì ê¹Œì§€ì˜ ìµœë‹¨ê±°ë¦¬ë¥¼ ê³„ì‚°í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ë‹¤. 

<span style="color:red; font-weight:bold;">ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì€ ê·¸ë˜í”„ì˜ ì–´ëŠ ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ë¼ë„ ìŒìˆ˜ê°€ ìˆìœ¼ë©´ ì•ˆëœë‹¤.</span> 

<br>

ë‹¤ìµìŠ¤íŠ¸ë¼ëŠ” ë°°ì—´ì„ ì´ìš©í•´ êµ¬í˜„í•  ìˆ˜ë„ ìˆê³ , ìš°ì„ ìˆœìœ„ íë¥¼ ì´ìš©í•´ êµ¬í˜„í•  ìˆ˜ë„ ìˆë‹¤. 

ì •ì ì˜ ê°œìˆ˜ë¥¼ V, ê°„ì„ ì˜ ê°œìˆ˜ë¥¼ Eë¼ê³  í–ˆì„ ë•Œ

ë°°ì—´ì„ ì´ìš©í•˜ëŠ” ê²½ìš° ì‹œê°„ë³µì¡ë„ëŠ” `O(V^2)` ì´ê³  ìš°ì„ ìˆœìœ„ íë¥¼ ì´ìš©í•˜ëŠ” ê²½ìš° `O(ElogV)`ì´ë‹¤.

ìš°ì„ ìˆœìœ„ íë¥¼ ì‚¬ìš©í•˜ëŠ”ê²Œ í›¨ì”¬ ë¹ ë¥´ê³  ê°„ë‹¨í•˜ë‹ˆ ìš°ì„ ìˆœìœ„ íë¥¼ ì´ìš©í•œ ë°©ë²•ì„ ì‚´í´ë³´ì.

<br>

``` cpp
#include <vector>
#include <iostream>
#include <queue>

#define MAX 100                                         // ìµœëŒ€ ì •ì ì˜ ê°œìˆ˜ 
#define INF 99999999

vector<int> dijkstra(int start, int V, vector<pair<int,int> > adj[]) {
    vector<int> dist(V, INF);                           // ì „ë¶€ INFë¡œ ì´ˆê¸°í™” 
    priority_queue<pair<int, int> > pq;
    
    dist[start] = 0;
    pq.push(make_pair(0, start));                       // ì‹œì‘ ì •ì  ë°©ë¬¸ 
 
    while (!pq.empty()) {
        int cost = -pq.top().first;                     // ë°©ë¬¸í•œ ì •ì ì˜ dist ê°’ 
        int cur = pq.top().second;                      // í˜„ì¬ ë°©ë¬¸í•œ ì •ì  
        pq.pop();
 
        for (int i = 0; i < adj[cur].size(); i++) {     // í˜„ì¬ ë°©ë¬¸í•œ ì •ì ì˜ ì£¼ë³€ ì •ì  ëª¨ë‘ ì¡°ì‚¬ 
            int next = adj[cur][i].first;               // ì¡°ì‚¬í•  ë‹¤ìŒ ì •ì  
            int nCost = cost + adj[cur][i].second;      // í˜„ì¬ ë°©ë¬¸í•œ ì •ì ì„ ê±°ì³ì„œ ë‹¤ìŒ ì •ì ì„ ê°ˆë•Œì˜ ë¹„ìš© 
            if (nCost < dist[next] ) {                  // ê¸°ì¡´ ë¹„ìš©ë³´ë‹¤ í˜„ì¬ ë°©ë¬¸í•œ ì •ì ì„ ê±°ì¹œ ë¹„ìš©ì´ ë” ì‹¸ë‹¤ë©´ 
                dist[next] = nCost;                     // ê°±ì‹  
                pq.push(make_pair(-nCost, next));       // pqì— ì €ì¥ 
            }
        }
    }
    
    return dist;
}
 

// ì‚¬ìš© ì˜ˆ
int main()
{
    int V,E;
    vector<pair<int, int> > adj[MAX];
    cout << "ì •ì ì˜ ê°œìˆ˜ ì…ë ¥ : ";
    cin >> V;
    cout << "ê°„ì„ ì˜ ê°œìˆ˜ ì…ë ¥ : ";
    cin >> E;
 
    for (int i = 0; i < E; i++) {
        int from, to, cost;
        cin >> from >> to >> cost;
        adj[from].push_back(make_pair(to, cost));    // ì–‘ë°©í–¥ ê·¸ë˜í”„ 
        adj[to].push_back(make_pair(from, cost));
    }
 
    printf("\n===ë‹¤ìµìŠ¤íŠ¸ë¼ ê²°ê³¼===\n");
    vector<int> dist = dijkstra(0, V, adj);
    for (int i = 0; i < V; i++) {
        printf("0ë²ˆ ì •ì ì—ì„œ %dë²ˆ ì •ì ê¹Œì§€ ìµœë‹¨ê±°ë¦¬ : %d\n", i, dist[i]);
    }
    return 0;
}
```

> ì½”ë“œ ì¶œì € : [[ì•Œê³ ë¦¬ì¦˜] ë‹¤ìµìŠ¤íŠ¸ë¼(Dijkstra) ì•Œê³ ë¦¬ì¦˜ì´ë€? : c++ ë‹¤ìµìŠ¤íŠ¸ë¼ êµ¬í˜„](https://code-lab1.tistory.com/29)

<br>

---

### ğŸ’  Bellman-ford

ë²¨ë§Œí¬ë“œ ì•Œê³ ë¦¬ì¦˜ì€ 'ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ë¥¼ ë‹¤ íƒìƒ‰í•´ ê°€ë©´ì„œ ìµœì†Œë¹„ìš©'ì„ ì°¾ê²Œ ëœë‹¤. 

ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ê³¼ëŠ” ë‹¬ë¦¬ ê·¸ë¦¬ë”” í•˜ì§€ ì•Šê²Œ ë™ì‘í•œë‹¤. 

> 1. ëª¨ë“  ê°„ì„ ë“¤ì„ íƒìƒ‰í•˜ë©´ì„œ, ê°„ì„ ì´ ì‡ëŠ” ì¶œë°œì •ì ì´ 'í•œë²ˆì´ë¼ë„ ê³„ì‚° ëœ ì •ì ' ì´ë¼ë©´ í•´ë‹¹ ê°„ì„ ì´ ì‡ëŠ” ì •ì ì˜ ê±°ë¦¬ë¥¼ ë¹„êµí•´ì„œ ì—…ë°ì´íŠ¸ í•œë‹¤.
> 2. 1ë²ˆ ê³¼ì •ì„ ë°˜ë³µí•œë‹¤.

<br>

ì•„ë˜ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ê¸° ì „, ë‹¤ìŒ ë‘ ì¡°ê±´ì„ ë§Œì¡±í•´ì•¼ í•œë‹¤.

* Distë°°ì—´ì˜ ì´ˆê¸°ìƒíƒœëŠ” ëª¨ë‘ `'INF(ë¬´í•œëŒ€)'` ë¡œ ì´ˆê¸°í™” ë˜ì–´ ìˆëŠ” ìƒíƒœì´ë‹¤.
* ê·¸ë¦¬ê³ , 'Edge'ëŠ” ê°„ì„ ì˜ ì •ë³´ë¥¼ ì €ì¥í•œ vectorì¸ë°, Edgeì—ëŠ” `{ ì‹œì‘ì , ë„ì°©ì , ë¹„ìš© }` ì´ ì €ì¥ë˜ì–´ ìˆë‹¤.

<br>

``` cpp
void Bellman_Ford()
{
    Dist[1] = 0;
    for (int i = 1; i <= N - 1; i++)
    {
        for (int j = 0; j < Edge.size(); j++)
        {
            int From = Edge[j].first.first;
            int To = Edge[j].first.second;
            int Cost = Edge[j].second;
 
            if (Dist[From] == INF) continue;
            if (Dist[To] > Dist[From] + Cost) Dist[To] = Dist[From] + Cost;
        }
    }
 
    for (int i = 0; i < Edge.size(); i++)
    {
        int From = Edge[i].first.first;
        int To = Edge[i].first.second;
        int Cost = Edge[i].second;
 
        if (Dist[From] == INF) continue;
        if (Dist[To] > Dist[From] + Cost)
        {
            cout << "ìŒì˜ ì‚¬ì´í´ì´ ì¡´ì¬í•˜ëŠ” ê·¸ë˜í”„ì…ë‹ˆë‹¤." << endl;
            return;
        }
    }
    cout << "ìŒì˜ ì‚¬ì´í´ì´ ì¡´ì¬í•˜ì§€ ì•ŠëŠ”, ì •ìƒì ì¸ ê·¸ë˜í”„ ì…ë‹ˆë‹¤." << endl;
}
```

> ì½”ë“œ ì¶œì € : [[ ë²¨ë§Œí¬ë“œ ì•Œê³ ë¦¬ì¦˜ ] ê°œë…ê³¼ êµ¬í˜„ë°©ë²• (C++)](https://yabmoons.tistory.com/365)

<Br>

---

### ğŸ’  Floyd-warshall

í”Œë¡œì´ë“œ-ì™€ìƒ¬ ì•Œê³ ë¦¬ì¦˜ì€ 'ëª¨ë“ ì •ì 'ì—ì„œ 'ëª¨ë“ ì •ì 'ìœ¼ë¡œì˜ ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ë‹¤. 

``` cpp
int INF = 1000000;

int a[4][4] = {
  { 0, 5, INF, 8 },
  { 7, 0, 9, INF },
  { 2, INF, 0, 4 },
  { INF, INF, 3, 0 }
};

// ì‹œê°„ë³µì¡ë„ V^3
for(int k = 0; k < 4; k++)              // k ëŠ” ê±°ì³ê°€ëŠ” ì •ì 
  for(int i = 0; i < 4; i++)              // i ëŠ” í–‰ (ì¶œë°œ ì •ì )
    for(int j = 0; j < 4; j++)          // j ëŠ” ì—´ (ë„ì°© ì •ì )
      if (a[i][k] + a[k][j] < a[i][j])  // ì í™”ì‹ distance[i,j] = min(distance[i,j], distance[i,n] + distance[n,j])
        a[i][j] = a[i][k] + a[k][j];
```

> ì½”ë“œ ì¶œì € : [24. í”Œë¡œì´ë“œ ì™€ìƒ¬(Floyd Warshall) ì•Œê³ ë¦¬ì¦˜](https://m.blog.naver.com/PostView.nhn?blogId=ndb796&logNo=221234427842&proxyReferer=https:%2F%2Fwww.google.com%2F)

<Br>

---

### ğŸ’  Prim

ê·¸ë˜í”„ ë‚´ ëª¨ë“  ì •ì ì„ í¬í•¨í•˜ëŠ” íŠ¸ë¦¬ (ì‹ ì¥íŠ¸ë¦¬, Spanning Tree)ì¤‘ì—ì„œ, ê°€ì¥ ë¹„ìš©ì´ ì €ë ´í•œ íŠ¸ë¦¬ë¥¼

ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ (Minimum Spanning Tree)ë¼ê³  í•œë‹¤.

ì•„ë˜ ì˜ˆì‹œëŠ” [í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ ì„¬ ì—°ê²°í•˜ê¸°]() ë¬¸ì œë¥¼ í•´ê²°í•œ ì½”ë“œ

ì½”ë“œ í•´ì„¤ì€ [ì´ ë¸”ë¡œê·¸](https://mind-devlog.tistory.com/89)ë¥¼ ì°¸ê³ í–ˆë‹¤.

> ìš°ì„ , ì£¼ì–´ì§„ costs ë²¡í„°ë¥¼ í™œìš©í•˜ì—¬ ì¸ì ‘ í–‰ë ¬ì„ ë§Œë“¤ì–´ì£¼ì—ˆë‹¤.
> 
> ê·¸ í›„, ë°©ë¬¸í•œ ì„¬ê³¼ ë°©ë¬¸í•˜ì§€ ì•Šì€ ì„¬ì˜ ì¸ë±ìŠ¤ë¥¼ êµ¬ë¶„í•´ì£¼ê¸° ìœ„í•´,
> 
> ì‹œì‘ ìœ„ì¹˜ì¸ 0ì„ visited ë²¡í„°ì— ë„£ê³ , ê·¸ ì™¸ì˜ ì„¬ë“¤ì˜ ì¸ë±ìŠ¤ë¥¼ unvisited ë²¡í„°ì— ë„£ì–´ì£¼ì—ˆë‹¤.
>
> <br>
> 
> whileë¬¸ì—ì„œëŠ”Â í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ì„ í™œìš©í•˜ì—¬ ë‹¤ë¦¬ë¥¼ ì„ íƒí•´ì£¼ì—ˆë‹¤.
> 
> ì¦‰, ë°©ë¬¸í•œ ì„¬ì—ì„œ ë°©ë¬¸í•˜ì§€ ì•Šì€ ì„¬ìœ¼ë¡œ ì—°ê²°í•  ìˆ˜ ìˆëŠ” ë‹¤ë¦¬ë“¤ ì¤‘ ìµœì†Œ ë¹„ìš©ì´ ë“œëŠ” ë‹¤ë¦¬ë¥¼ ì„ íƒí•´ì£¼ì—ˆë‹¤.
> 
> ì„ íƒí•œ ë‹¤ë¦¬ì™€ ì—°ê²°ë˜ì–´ ìˆëŠ” ì„¬ì€ ë°©ë¬¸í•œ ì„¬ì— ì¶”ê°€í•˜ê³ , ë°©ë¬¸í•˜ì§€ ì•Šì€ ì„¬ì—ì„œ ì œê±°í•´ì£¼ì—ˆë‹¤.
> 
> <br>
> Â 
> ìœ„ì˜ ë°©ì‹ì„ **n - 1**ê°œì˜ ë‹¤ë¦¬ë¥¼ ì„ íƒí•  ë•Œê¹Œì§€ ìˆ˜í–‰í•˜ì—¬ ìµœì¢…ì ì¸ ìµœì†Œ ë¹„ìš©ì„ êµ¬í•´ì£¼ì—ˆë‹¤.
> 
> *(n - 1ê°œì˜ ë‹¤ë¦¬ë¥¼ ì„¤ì¹˜í•´ì•¼ ëª¨ë“  ì„¬ì„ ì—°ê²°í•  ìˆ˜ ìˆë‹¤.)*

<br>

``` cpp
#include <string>
#include <vector>
#include <algorithm>
#include <limits.h>

using namespace std;

int solution(int n, vector<vector<int>> costs) {
	int answer = 0;

	vector<vector<int>> graph(n, vector<int>(n));
	for (int i = 0; i < costs.size(); i++)
	{
		graph[costs[i][0]][costs[i][1]] = costs[i][2];
		graph[costs[i][1]][costs[i][0]] = costs[i][2];
	}

	vector<int> visited;
	vector<int> unvisited;

	visited.push_back(0);
	for (int i = 1; i < n; i++)
		unvisited.push_back(i);

	for (int i = 1; i < n; i++)
	{
		int min = INT_MAX;
		int min_index = 0;

		for (int j = 0; j < i; j++)
		{
			for (int k = 0; k < n - i; k++)
			{
				if (graph[visited[j]][unvisited[k]] > 0 && min > graph[visited[j]][unvisited[k]])
				{
					min = graph[visited[j]][unvisited[k]];
					min_index = k;
				}
			}
		}

		visited.push_back(unvisited[min_index]);
		unvisited.erase(unvisited.begin() + min_index);
		answer += min;
	}

	return answer;
}
```

> ì½”ë“œ ì¶œì € : [[í”„ë¡œê·¸ë˜ë¨¸ìŠ¤][ê·¸ë¦¬ë””][C++] ì„¬ ì—°ê²°í•˜ê¸°](https://mind-devlog.tistory.com/89)

<br><br><br>

---

<br><br><br>

## ğŸ”¶ III. ë¬¸ìì—´

### ğŸ’  KMP (Knuth-Morris-Pratt)

ì–´ë–¤ ë¬¸ìì—´ì—ì„œ ì›í•˜ëŠ” ë¬¸ìì—´ì„ ê²€ìƒ‰í•  ë•Œ ê·¸ ê²€ìƒ‰ì–´ì˜ ìœ„ì¹˜ë¥¼ ì°¾ì•„ì£¼ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ë‹¤.

Nì„ í…ìŠ¤íŠ¸ì˜ ê¸¸ì´, Mì„ ê²€ìƒ‰ì–´ì˜ ê¸¸ì´ë¼ê³  í•  ë•Œ, ì‹œê°„ë³µì¡ë„ëŠ” `O(N+M)`

í…ìŠ¤íŠ¸ ì•ˆì— ê²€ìƒ‰í•˜ê³ ì í•˜ëŠ” ê²€ìƒ‰ì–´ê°€ í•˜ë‚˜ ì¼ ë•Œ ì‚¬ìš©í•œë‹¤. **( í…ìŠ¤íŠ¸ : ê²€ìƒ‰ì–´ = 1 : 1)**

<br>

``` cpp
using namespace std;

vector<int> Fail(string pattern) {
    int m = pattern.length();
    vector<int> pi(m); // partial match table

    pi[0] = 0;
    for (int i = 1, j = 0; i < m; i++) {
        while (j > 0 && pattern[i] != pattern[j])
            j = pi[j - 1];
        if (pattern[i] == pattern[j])
            pi[i] = ++j;
    }
    return pi;
}

vector<int> KMP(string pattern, string text) {
    int m = pattern.length(); 
    int n = text.length(); 
    vector<int> pos; 
    vector<int> pi = Fail(pattern); 

    for (int i = 0, j = 0; i < n; i++) {
        while (j > 0 && text[i] != pattern[j])
            j = pi[j - 1];
        if (text[i] == pattern[j]) { 
            if (j == m - 1) { 
                pos.push_back(i - m + 1);
                j = pi[j]; 
            }
            else j++; 
        }
    }
    return pos;
}
```

> ì½”ë“œ ì¶œì € : [(C++) ë¬¸ìì—´ ê²€ìƒ‰ ì•Œê³ ë¦¬ì¦˜ : KMP ì•Œê³ ë¦¬ì¦˜](https://ansohxxn.github.io/algorithm/kmp/)

<br>

---

### ğŸ’  Aho-Corasick

ì–´ë–¤ ë¬¸ìì—´ì—ì„œ ì—¬ëŸ¬ ë¬¸ìì—´ë“¤ì„ ë™ì‹œì— ì°¾ì•„ì•¼ í•˜ëŠ” ìƒí™©ì—ì„œ ì“°ì´ëŠ” ì•Œê³ ë¦¬ì¦˜ **( í…ìŠ¤íŠ¸ : ê²€ìƒ‰ì–´ = 1 : å¤š)**

> ex) â€œcacachefcachyâ€ í…ìŠ¤íŠ¸ì— { â€œcacheâ€, â€œheâ€, â€œchefâ€, â€œarchyâ€ } ä¸­ í•˜ë‚˜ë¼ë„ ë¶€ë¶„ ë¬¸ìì—´ë¡œ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ ì°¾ê¸°.

Nì„ í…ìŠ¤íŠ¸ì˜ ê¸¸ì´, Mì„ ê²€ìƒ‰ì–´ì˜ ê¸¸ì´,kë¥¼ ê²€ìƒ‰ì–´ì˜ ê°œìˆ˜ë¼ê³  í•  ë•Œ, ì‹œê°„ë³µì¡ë„ëŠ” `O(N + M1 + M2 + ... + MK)`

<br>

``` cpp
#include <bits/stdc++.h>

using namespace std;

struct Trie {                           // ë…¸ë“œ ê°ì²´ í´ë˜ìŠ¤
public:
    bool isEnd;                         // ì´ ë…¸ë“œê°€ í•œ ê²€ìƒ‰ì–´ì˜ ëì¸ì§€ ì•„ë‹Œì§€ë¥¼ ì•Œë ¤ì¤Œ 
    string p;                           // ì´ ë…¸ë“œê¹Œì§€ì˜ ì ‘ë‘ì‚¬ (ì•„í˜¸ ì½”ë¼ì‹ì˜ í•„ìš”í•œ ë¶€ë¶„ì€ ì•„ë‹ˆë‹¤.)
    map<char, Trie*> child;             // ìì‹ ë…¸ë“œ ë§í¬
    Trie* fail;                         // ì‹¤íŒ¨ ë§í¬ â­

    Trie() : isEnd(false), fail(nullptr) {}

    void Insert(string pattern) {
        Trie* now = this;
        int m = pattern.length();
        for (int i = 0; i < m; ++i) {
            if (now->child.find(pattern[i]) == now->child.end())
                now->child[pattern[i]] = new Trie;
            now = now->child[pattern[i]];

            if (i == m - 1) {
                now->p = pattern;
                now->isEnd = true;
            }
        }
    }

    void Fail() {  // BFS + KMP
        Trie* root = this;
        queue<Trie*> q;

        q.push(root);

        while (!q.empty()) {
            Trie* now = q.front();
            q.pop();

            for (auto& ch : now->child) {

                Trie* next = ch.second;
                if (now == root)
                    next->fail = root;
                else {
                    Trie* prev = now->fail;
                    while (prev != root && prev->child.find(ch.first) == prev->child.end())
                        prev = prev->fail;
                    if (prev->child.find(ch.first) != prev->child.end())
                        prev = prev->child[ch.first];
                    next->fail = prev;
                }

                if (next->fail->isEnd)
                    next->isEnd = true;

                q.push(next);
            }
        }
    }
};

vector<pair<string, int>> KMP(string text, Trie* root) {
    Trie* now = root;
    int n = text.length();
    vector<pair<string, int>> answer;
    for (int i = 0; i < n; ++i) {
        while (now != root && now->child.find(text[i]) == now->child.end())
            now = now->fail;
        if (now->child.find(text[i]) != now->child.end())
            now = now->child[text[i]];
        if (now->isEnd) {
            answer.push_back({ now->p, i });
        }
    }
    return answer;
}

int main() {
    freopen("input.txt", "r", stdin);

    int N;
    cin >> N;
    vector<string> patterns(N);
    for (int i = 0; i < N; ++i)
        cin >> patterns[i];
    Trie* root = new Trie;
    for (int i = 0; i < N; ++i)
        root->Insert(patterns[i]);
    root->Fail();

    string text;
    cin >> text;

    vector<pair<string, int>> answer = KMP(text, root);
    cout << text << "ì—ì„œ ê²€ìƒ‰í•˜ê¸°" << '\n';
    for (int i = 0; i < answer.size(); ++i) 
        cout << "í™•ì¸ëœ ê²€ìƒ‰ì–´ : " << answer[i].first << ", ìœ„ì¹˜ : " << answer[i].second << '\n';
}

```

ìì„¸í•œ ì„¤ëª…ì€ ì•„ë˜ ë¸”ë¡œê·¸ ì°¸ì¡°

> ì½”ë“œ ì¶œì € : [(C++) ë¬¸ìì—´ ê²€ìƒ‰ ì•Œê³ ë¦¬ì¦˜ : ì•„í˜¸-ì½”ë¼ì‹(Aho-Corasick) ì•Œê³ ë¦¬ì¦˜](https://ansohxxn.github.io/algorithm/ahocorasick/)

<br><br><br>

---

<br><br><br>

## ğŸ”¶ IV. ê¸°íƒ€

### ğŸ’  íˆ¬í¬ì¸í„°

ë°°ì—´ì—ì„œ ì›ë˜ ì´ì¤‘ forë¬¸ìœ¼ë¡œ O(N^2)ì— ì²˜ë¦¬ë˜ëŠ” ì‘ì—…ì„ 2ê°œì˜ í¬ì¸í„°ì˜ ì›€ì§ì„ìœ¼ë¡œ O(N)ì— í•´ê²°í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ë‹¤.

ì—¬ê¸°ì„œ í¬ì¸í„°ëŠ” Cì–¸ì–´ì˜ í¬ì¸í„°ê°€ ì•„ë‹ˆë¼ ì‘ì—…ì„ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ ìƒì„±í•œ ë³€ìˆ˜ì´ë‹¤. í¬ì¸í„°ë¼ëŠ” ë³€ìˆ˜ë¥¼ ë‘ê°œë¥¼ ì„ ì–¸í•´ì„œ íˆ¬ í¬ì¸í„°ë¼ê³  ë¶€ë¥¸ë‹¤.

ì˜ˆë¥¼ë“¤ë©´, íŠ¹ì • ì—°ì†ëœ êµ¬ê°„ì˜ í•©ì´ Mì´ ë˜ëŠ” ê²½ìš°ì˜ ìˆ˜ë¥¼ êµ¬í•˜ëŠ” ì½”ë“œëŠ” ì•„ë˜ì™€ ê°™ë‹¤.

<br>

``` cpp
#include <iostream>
using namespace std;
 
int main(){
    int N, M, arr[10000];
    cin >> N >> M;
    for(int i=0; i<N; i++){
        cin >> arr[i];
    }
        
    int answer = 0, sum = 0, s = 0, e = 0;
    while(s<N){
        if(sum >= M){ 
            sum -= arr[s];
            s++;
        }else{
            sum += arr[e];
            e++;
        } 
        if(sum == M) answer++;
    }
    
    cout << answer;
}
```

> ì½”ë“œ ì¶œì € : [[ì•Œê³ ë¦¬ì¦˜] íˆ¬ í¬ì¸í„° ì•Œê³ ë¦¬ì¦˜(Two-Pointers Algorithm)ì´ë€? ë°±ì¤€ 2003ë²ˆ C++ í’€ì´](https://code-lab1.tistory.com/276)

<br>

---

### ğŸ’  Union Find

Disjoint Setì„ í‘œí˜„í•  ë•Œ ì‚¬ìš©í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜

> #### ğŸ“ŒDisjoint Setì´ë€
>
> ì„œë¡œ ì¤‘ë³µë˜ì§€ ì•ŠëŠ” ë¶€ë¶„ ì§‘í•©ë“¤ ë¡œ ë‚˜ëˆ ì§„ ì›ì†Œë“¤ì— ëŒ€í•œ ì •ë³´ë¥¼ ì €ì¥í•˜ê³  ì¡°ì‘í•˜ëŠ” ìë£Œêµ¬ì¡°
> 
> ì¦‰, ê³µí†µ ì›ì†Œê°€ ì—†ëŠ”, ì¦‰ `ìƒí˜¸ ë°°íƒ€ì ` ì¸ ë¶€ë¶„ ì§‘í•©ë“¤ë¡œ ë‚˜ëˆ ì§„ ì›ì†Œë“¤ì— ëŒ€í•œ ìë£Œêµ¬ì¡°ì´ë‹¤.
> **Disjoint Set = ì„œë¡œì†Œ ì§‘í•© ìë£Œêµ¬ì¡°**
>
> * ì°¸ê³ ìë£Œ : [[ì•Œê³ ë¦¬ì¦˜] Union-Find ì•Œê³ ë¦¬ì¦˜](https://gmlwjd9405.github.io/2018/08/31/algorithm-union-find.html)

ì§‘í•©ì„ êµ¬í˜„í•˜ëŠ” ë°ëŠ” ë¹„íŠ¸ ë²¡í„°, ë°°ì—´, ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¥¼ ì´ìš©í•  ìˆ˜ ìˆìœ¼ë‚˜ ê·¸ ì¤‘ ê°€ì¥ íš¨ìœ¨ì ì¸ íŠ¸ë¦¬ êµ¬ì¡°ë¥¼ ì´ìš©í•˜ì—¬ êµ¬í˜„í•œë‹¤.

<br>

``` cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int parent[10];
int ran[10];

int find(int u) {
    if (u == parent[u]) return u;
    return parent[u] = find(parent[u]);
}

void merge(int u, int v) {
    u = find(u);
    v = find(v);
    if (u == v) return;
    if (ran[u] > ran[v]) swap(u, v);
    parent[u] = v;
    if (ran[u] == ran[v]) ran[v]++;
}

int main() {
    for (int i = 0; i <= 7; i++) {
        parent[i] = i;
        ran[i] = 1;
    }
}
```

> ì½”ë“œ ì¶œì € : [ìœ ë‹ˆì˜¨ íŒŒì¸ë“œ(Union Find) c++](https://m.blog.naver.com/fbfbf1/222278788809)

<br><br><br>

---

<br><br><br>

## ğŸ”¶ V. ìˆœì—´ê³¼ ì¡°í•©

### ğŸ’  ìˆœì—´ (Permutation)

ì„ íƒ ìˆœì„œê°€ ê²°ê³¼ì— ì˜í–¥ì„ ë¯¸ì¹˜ëŠ” ê²½ìš°! `(1,2)`ì™€ `(2,1)`ì€ ë‹¬ë¼ì•¼ í•  ë•Œ

> #### ğŸ“Œ íŠ¹ì§•
> 
> * ì¤‘ë³µì„ í—ˆìš©í•˜ì§€ ì•ŠëŠ”ë‹¤.
> * nPr
>     * `5P3` = `5 X 4 X 3`
>     * `4P1` = `4`
>     * `4P4` = `4!` = `4 X 3 X 2 X 1`

<br>

``` cpp
#include <iostream>

using namespace std;

void swap(char & a, char & b)
{
    char temp = a;
    a = b;
    b = temp;
}

void permutation(char data [], int depth, int n, int r)
{
    if (depth == r)
    {
        for(int i = 0; i < r; i++)
            cout << data[i] << " ";
        cout << endl;
        
        return;
    }
    
    for(int i = depth; i < n; i++)
    {
        swap(data[depth], data[i]);          // ìŠ¤ì™‘
        permutation(data, depth + 1, n, r);  // ì¬ê·€
        swap(data[depth], data[i]);          // ë‹¤ì‹œ ì›ë˜ ìœ„ì¹˜ë¡œ ë˜ëŒë¦¬ê¸°
    }
}
```

> ì½”ë“œ ì¶œì € : [(C++) ìˆœì—´(Permutation) êµ¬í˜„í•˜ê¸°](https://ansohxxn.github.io/algorithm/permutation/)

STL í•¨ìˆ˜ `next_permutation(vec.begin(), vec.end())` ë˜ëŠ” `prev_permutation(vec.begin(),vec.end())`ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì€ 

[ì´ ë¸”ë¡œê·¸](https://ansohxxn.github.io/algorithm/permutation/)ì°¸ê³ 

STL í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ ë‹¤ìŒ 2ê°€ì§€ íŠ¹ì§•ì´ ìˆë‹¤.

* `next_permutation`, `prev_permutation`ìœ¼ë¡œ ëª¨ë“  ìˆœì—´ì„ êµ¬í•˜ë ¤ë©´ ë°˜ë“œì‹œ ì˜¤ë¦„ ì°¨ìˆœ ì •ë ¬ì´ ë˜ì–´ ìˆì–´ì•¼ í•œë‹¤.
* ì¤‘ë³µì„ ì œì™¸í•˜ê³  ì •ë ¬ì´ ëœë‹¤.

<br>

---

### ğŸ’  ì¤‘ë³µ ìˆœì—´ (Repeated Permutation)

ì„ íƒ ìˆœì„œê°€ ê²°ê³¼ì— ì˜í–¥ì„ ë¯¸ì¹˜ëŠ” ê²½ìš°! `(1,2)`ì™€ `(2,1)`ì€ ë‹¬ë¼ì•¼ í•  ë•Œ

> #### ğŸ“Œ íŠ¹ì§•
> 
> * ì¤‘ë³µì„ í—ˆìš©í•œë‹¤.
> * nÎ r
>     * `5Î 3` = `5 X 5 X 5`

<br>

``` cpp
#include <iostream>
#include <vector>

using namespace std;

void repeatPermutation(vector<char> vec, vector<char> perm, int depth)
{
    if (depth == perm.size())
    {
        for(int i = 0; i < perm.size(); i++)
        {
            cout << perm[i] << " ";
        }
        cout << endl;
        
        return;
    }
    
    for(int i = 0; i < vec.size(); i++)
    {
        perm[depth] = vec[i];
        repeatPermutation(vec, perm, depth + 1);
    }
}

int main()
{
    const int r = 3;
    
    vector<char> v = {'a', 'b'};
    vector<char> perm(r);
    
    repeatPermutation(v, perm, 0);  // {'a', 'b'}ì˜ ê¸¸ì´ 3ì˜ ì¤‘ë³µìˆœì—´ ëª¨ë‘ ì¶œë ¥í•˜ê¸°

    return 0;
}
```

> ì½”ë“œ ì¶œì € : [(C++) ì¤‘ë³µ ìˆœì—´(Repeated Permutation) êµ¬í˜„í•˜ê¸°](https://ansohxxn.github.io/algorithm/repeated-permutation/)

<br>

---

### ğŸ’  ì¡°í•© (Combination)

ì„ íƒ ìˆœì„œê°€ ê²°ê³¼ì— ì˜í–¥ì„ ì£¼ì§€ ì•ŠëŠ” ê²½ìš°! `(1,2)`ì´ë‚˜ `(2,1)`ì´ë‚˜ ê²°ê³¼ê°€ ê°™ì„ ë•Œ

> #### ğŸ“Œ íŠ¹ì§•
> 
> * ì¤‘ë³µì„ í—ˆìš©í•˜ì§€ ì•ŠëŠ”ë‹¤.
> * nCr
>     * `5C3` = `5P3 / 3!` =  `5 X 4 X 3 / 3 X 2 X 1` 

<br>

``` cpp
#include <iostream>
#include <vector>

using namespace std;

void Combination(vector<char> arr, vector<char> comb, int index, int depth)
{
    if (depth == comb.size())
    {
        for(int i = 0; i < comb.size(); i++)
            cout << comb[i] << " ";
        cout << endl;
        
        return;
    }
    else
    {
        for(int i = index; i < arr.size(); i++)
        {
            comb[depth] = arr[i];
            Combination(arr, comb, i + 1, depth + 1);
        }
    }
}

int main()
{
    vector<char> vec = {'a', 'b', 'c', 'd', 'e'};  // n = 5
    
    int r = 3;
    vector<char> comb(r);
    
    Combination(vec, comb, 0, 0);  // {'a', 'b', 'c', 'd', 'e'}ì˜ '5C3' êµ¬í•˜ê¸° 

    return 0;
}
```

> ì½”ë“œ ì¶œì € : [(C++) ì¡°í•©(Combination) êµ¬í˜„í•˜ê¸°](https://ansohxxn.github.io/algorithm/combination/)

<Br>

---

### ğŸ’  ì¤‘ë³µ ì¡°í•© (Repeated Combination)

ì„ íƒ ìˆœì„œê°€ ê²°ê³¼ì— ì˜í–¥ì„ ì£¼ì§€ ì•ŠëŠ” ê²½ìš°! `(1,2)`ì´ë‚˜ `(2,1)`ì´ë‚˜ ê²°ê³¼ê°€ ê°™ì„ ë•Œ

> #### ğŸ“Œ íŠ¹ì§•
> 
> * ì¤‘ë³µì„ í—ˆìš©í•œë‹¤.
> * nCr
>     * `nHr` = `n-1+r C n-1` = `n-1+r C r`
>     * `5H3` = `5-1+3 C 3` = `7C3` = `35`

<br>

``` cpp
#include <iostream>
#include <vector>

using namespace std;

void Combination(vector<char> arr, vector<char> comb, int index, int depth)
{
    if (depth == comb.size()) 
    {
        for(int i = 0; i < comb.size(); i++)
            cout << comb[i] << " ";
        cout << endl;
        
        return;
    }
    else
    {
        for(int i = index; i < arr.size(); i++)
        {
            comb[depth] = arr[i];
            Combination(arr, comb, i, depth + 1);
        }
    }
}

int main()
{
    vector<char> vec = {'a', 'b', 'c', 'd'};   // n = 5
    
    int r = 3;
    vector<char> comb(r);
    
    Combination(vec, comb, 0, 0);  // {'a', 'b', 'c', 'd'}ì˜ ì¤‘ë³µì¡°í•© '4H3' êµ¬í•˜ê¸° 

    return 0;
}
```

> ì½”ë“œ ì¶œì € : [(C++) ì¤‘ë³µ ì¡°í•©(Repeated Combination) êµ¬í˜„í•˜ê¸°](https://ansohxxn.github.io/algorithm/repeated-combination/)

<br><br><br>
