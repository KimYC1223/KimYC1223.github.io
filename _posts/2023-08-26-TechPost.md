---
layout: post
pagination: 
  enabled: true
type: tech
date: 2023-08-26 09:26
category: Blog
title: Effective C# - LINQ 활용
subtitle: C#에서의 LINQ 활용
writer: KimYC1223
post-header: false
image: title.png
tags: [C_Sharp]
draft : false
---

{% capture img_url %}/assets/blog/{{page.date | date: "%Y-%m-%d"}}-TechPost{% endcapture %}

Effective C# 4판 스터디, 그 세 번째 포스트

# 📚 목차

> - 🔸 ITEM 29: 컬렉션을 반환하기보다 이터레이터를 반환하는 것이 낫다
> - 🔸 ITEM 30: 루프보다 쿼리구문이 낫다.
> - 🔸 ITEM 31: 시퀀스에 사용할 수 있는 조합 가능한 API를 작성하라
> - 🔸 ITEM 32: Action, Predicate, Function과 순회 방식을 분리하라
> - 🔸 ITEM 33. 필요한 시점에 필요한 요소를 생성하라.
> - ~~🔸 ITEM 34. 함수를 매개변수로 사용하여 결합도를 낮춰라.~~
> - ~~🔸 ITEM 35. 확장 메서드는 절대 오버로드 하지마라.~~
> - ~~🔸 ITEM 36. 쿼리 표현식과 메서드 호출 구문이 어떻게 대응되는지 이해하라.~~
> - ~~🔸 ITEM 37. 쿼리를 사용할 때는 즉시 평가보다 지연 평가가 낫다.~~
> - ~~🔸 ITEM 38. 메서드보다 람다 표현식이 낫다.~~
> - ~~🔸 ITEM 39. function과 action 내에서는 예외가 발생하지 않도록 하라~~
> - ~~🔸 ITEM 40. 지연 수행과 즉시 수행을 구분하라~~
> - ~~🔸 ITEM 41. 값비싼 리소스를 캡처하지말라~~
> - ~~🔸 ITEM 42. `IEnumerable<T>` 데이터 소스와 `IQueryable<T>`이터 소스를 구분하라~~
> - ~~🔸 ITEM 43. 쿼리 결과의 의미를 명확히 강제하고 `Single()`과 `First()`를 사용하라~~
> - ~~🔸 ITEM 44. 바인딩된 변수는 수정하지 말라~~

<Br>

---

<br>

**LINQ(Language-INtegrated Query)**의 약자인 LINQ는 데이터 질의(Query) 기능을 C#에서 사용할 수 있는 기술이다.

쉽게 설명하자면 C#의 배열, 컬렉션, XML, DataSet 등등에서 내가 원하는 데이터만 가져오고 싶은 경우 사용할 수 있는 기술이다.

다음 예제는 배열에서 대문자 "A"로 시작하고 문자열의 길이가 3보다 큰 문자열을 **LINQ로 추출한 뒤** 콘솔에 출력합니다.

``` cs
static void Main(string[] args)
{
    string[] strArr = { "Apple", "Banana", "Car", "Angular", "Add", "Sum" };

    var linqResult = from str in strArr
                        where str.StartsWith("A") && str.Length > 3
                        select str;

    foreach (var str in linqResult)
        Console.Write(str + " ");
}
```

```
Apple Angular
```

반복문과 조건문 없이 LINQ에서 사용할 수 있는 문법을 사용하여 원하는 문자열을 추출하였다.

LINQ는 C# 및 VB.net에서만 사용할 수 있다.

### 주요 기능

| 기능 | 설명 |
|:---:|:---|
| LINQ to objects |  배열, 컬렉션, 제네릭 컬렉션에서 LINQ를 사용하여 원하는 데이터를 추출할 수 있다. |
| LINQ to XML |  XML 문서에서 LINQ를 사용하여 원하는 데이터를 추출할 수 있다. |
| LINQ to SQL |  SQL 서버의 데이터베이스와 함께 동작할 수 있다. |
| LINQ to DataSet |  DataSet에 LINQ를 사용하여 원하는 데이터를 추출할 수 있다. |

### LINQ의 장점

* SQL과 유사하므로 SQL 사용이 익숙하다면, 쉽게 접근할 수 있다.
* LINQ는 컴파일 시간에 타입을 체크한다. 따라서, 프로그램 실행 전에 문제가 되는 코드를 수정할 수 있다.
* 반복문, 조건문을 사용하는 것보다 코드가 단순해진다.
* LINQ의 질의는 재사용할 수 있다.

### LINQ의 장점

* RDBMS를 사용해보지 않은 개발자에게는 어려울 수 있다.
* SQL과 유사하지만, 복잡한 질의(Query)는 작성할 수 없다.
* 질의가 잘못된 경우 for, foreach와 같은 반복문을 사용하는 것보다 성능이 저하될 수 있다.

<br>

---

<br>

## 🔸 ITEM 29: 컬렉션을 반환하기보다 이터레이터를 반환하는 것이 낫다

이터레이터 메서드

- 호출자가 시퀀스를 만들어내기 위해 yield return 을 사용하는 것을 말한다.

단한 예제로 아래 코드를 살펴보자. `GetNumber()` 라는 메서드는 3개의 yield return 문을 가지고 있다. 

만약 외부에서 이 GetNumber()를 호출하게 되면, 첫번째 호출시에는 첫번째 yield return 10 을 실행하여 10을 리턴하게 되고, 

두번째로 호출되면 yield return 20 이 실행되어 20을 리턴하게 된다. 

이러한 방식으로 GetNumber()는 한꺼번에 10,20,30을 모두 리턴하는 것이 아니라, 

한번 호출시마다 다음 yield return 문의 값을 리턴하는 것이다.

``` cs
using System;
using System.Collections.Generic;

class Program
{
    static IEnumerable<int> GetNumber()
    {
        yield return 10;  // 첫번째 루프에서 리턴되는 값
        yield return 20;  // 두번째 루프에서 리턴되는 값
        yield return 30;  // 세번째 루프에서 리턴되는 값
    }

    static void Main(string[] args)
    {
        foreach (int num in GetNumber())
        {
            Console.WriteLine(num);
        }             
    }
}
```

이러한 특별한 리턴 방식은 다음과 같은 경우에 유용하게 사용된다.

* 만약 데이타의 양이 커서 모든 데이타를 한꺼번에 리턴하는 것하는 것 보다 조금씩 리턴하는 것이 더 효율적일 경우. 예를 들어, 어떤 검색에서 1만 개의 자료가 존재하는데, UI에서 10개씩만 On Demand로 표시해 주는게 좋을 수도 있다. 즉, 사용자가 20개를 원할 지, 1000개를 원할 지 모르기 때문에, 일종의 지연 실행(Lazy Operation)을 수행하는 것이 나을 수 있다.

* 어떤 메서드가 무제한의 데이타를 리턴할 경우. 예를 들어, 랜덤 숫자를 무제한 계속 리턴하는 함수는 결국 전체 리스트를 리턴할 수 없기 때문에 yield 를 사용해서 구현하게 된다.

* 모든 데이타를 미리 계산하면 속도가 느려서 그때 그때 On Demand로 처리하는 것이 좋은 경우. 예를 들어 소수(Prime Number)를 계속 리턴하는 함수의 경우, 소수 전체를 구하면 (물론 무제한의 데이타를 리턴하는 경우이기도 하지만) 시간상 많은 계산 시간이 소요되므로 다음 소수만 리턴하는 함수를 만들어 소요 시간을 분산하는 지연 계산(Lazy Calculation)을 구현할 수 있다.

<br>

---

<br>

## 🔸 ITEM 30: 루프보다 쿼리구문이 낫다

System.LINQ 네임스페이스에 포함된 쿼리 구문은 `IEnumerable<T>`에 대한 확장 인터페이스를 사용한다.

select, from, where, group by, order by와 같은 쿼리 구문을 사용할 수 있으며 C# 컴파일러가 일반 확장 메서드로 해석해준다.

쿼리 구문을 사용하면 복잡한 전처리 과정을 간단하게 쿼리식으로 표현가능하며 가독성이 높아지는 장점이 있다.

내부적으로는 `IEnumerable<T>`를 반환하는 이터레이터 메서드 처럼 동작하여 지연된 평가값이 반환된다.

``` cs
private static IEnumerable<Tuple<int, int>> ProduceIndices()
{
    var storage = new List<Tuple<int, int>>();

    for(var x = 0; x < 100; ++x)
    {
        for(var y = 0; y < 100; ++y)
        {
            if(x+y<100)
            {
                storage.Add(Tuple.Create(x, y));
            }
        }
    }

    storage.Sort((p1, p2) => (p2.Item1 * p2.Item1 + p2.Item2 * p2.Item2)
                .CompareTo((p1.Item1 * p1.Item1 + p1.Item2 * p1.Item2)));

    return storage;
}

private static IEnumerable<Tuple<int, int>> QueryIndices()
{
    return from x in Enumerable.Range(0, 100)
            from y in Enumerable.Range(0, 100)
            where x + y < 100
            orderby (x * x + y * y) descending
            select Tuple.Create(x, y);
}
```

<Br>

---

<br>

## 🔸 ITEM 31: 시퀀스에 사용할 수 있는 조합 가능한 API를 작성하라

반복 구문이 필요한 경우는 대부분 단일 요소가 아니라 시퀀스(컬렉션)를 처리하는 알고리즘을 작성하는 경우가 많다.

이 때, foreach 혹은 for, while을 사용하게 되는데, 이를 사용할 때에는 매개변수로 컬렉션을 받아와서 

컬렉션에 포함된 요소들을 살펴보거나, 내용을 수정하거나, 

혹은 그 중 일부만 필터링해서 또 다른 컬렉션에 그 결과를 저장한 후 반환하는 식으로 작성한다.

이는 효율성에 좋지않다. 그 이유는 전체 컬렉션을 대상으로 하나의 작업만을 하는 것이 아니고 

여러 작업 끝에 원하는 결과물을 얻을 수 있는 경우가 대부분이기 때문이며, 

이 작업에 대한 중간 결과물을 저장할 컬렉션이 필요할 수도 있다(큰 용량의 컬렉션일 수도 있다.)

<Br>

또한 하나의 컬렉션 전체에 대해 작업을 할 때 이 작업이 끝나기 전까지는 두 번째 작업을 못하게 되는데, 

이러한 작업을 하는 경우에는 대부분 각 작업마다 전체 컬렉션을 매번 순회해서 하기 때문에, 

다단계로 구성된 알고리즘을 수행하는 경우 전체적으로 수행 시간이 길어질 수 밖에 없다.

따라서 메서드를 각각의 작업별로 나누고 메서드를 호출하게 되면 중간 저장소도 필요없게 되고, 속도도 개선되지만, 

이렇게 되면 함수의 재사용성이 낮아진다.

<br>

따라서, 전 챕터에서도 말했듯이 시퀀스를 다루는 메서드를 사용할 때는 C# 이터레이터를 사용하는 것이 좋다.

이는 출력도 출력시퀀스에서 하고 싶을 때 할 수 있고, 입력의 경우에도 입력시퀀스에서 올바른 순서의 정보를 가져온다.

``` cs
public static IEnumerable<int> Unique(IEnumerable<int> nums)
{
    var uniqueVals = new HashSet<int>();
	
    foreach (var num in nums)
    {
    	if (!uniqueVals.Contains(num))
        {
        	uniqueVals.Add(num);
        	yield return num;
        }
    }
}
```

<Br>

---

<br>

## 🔸 ITEM 32: Action, Predicate, Function과 순회 방식을 분리하라

대리자를 이용하여 이터레이터 메서드와 같은 함수에서 사용되는 처리 기능을 분리하여 사용하는 것이 좋다.

`Where<T>` : 시퀀스 중 `Predicate<T>` 함수를 통과하는 원소만 반환한다.

``` cs
public static IEnumerable<T> Where<T>(IEnumerable<T> sequence, Predicate<T> filterFunc)
{
	if (filterFunc == null)
    	throw new ArgumentNullException("Predicate must not be null");
        
    foreach (T item in sequence)
    	if (filterFunc(item))
        	yield return item;
}
```

Select<T> : 시퀀스 원소를 순회하여 새로운 원소를 반환할 수 있다.

``` cs
public static IEnumerable<T out> Select<T in, T out>(IEnumerable<T in> sequence, Func<T in, T out> method)
{
	foreach (T element in sequence)
		yield return method(element);
}
```

<Br>

---

<br>

## 🔸 ITEM 33. 필요한 시점에 필요한 요소를 생성하라

이터레이터 메서드를 활용해서 컬렉션을 생성하는 것을 적극 고려한다.

이터레이터 메서드는 지연 평가로 원소가 생기는 시점을 나중으로 미루거나 `ToList()`와 같이 즉시 수행하도록 선택할 수 있다.

<br>

---

<br>

작성중...

<br>
<br>
