---
layout: post
pagination: 
  enabled: true
type: tech
date: 2023-08-12 03:10
category: Blog
title: Effective C# - Generic ν™μ©
subtitle: λ°νƒ€μ„μ—μ„ νƒ€μ…μ„ μ „λ‹¬ν•  μ μλ” Generic κΈ°λ²•μ„ ν¨κ³Όμ μΌλ΅ μ‚¬μ©ν•κΈ°
writer: KimYC1223
post-header: false
image: title.png
tags: [C_Sharp]
draft : false
---

{% capture img_url %}/assets/blog/{{page.date | date: "%Y-%m-%d"}}-TechPost{% endcapture %}

Effective C# 3ν μ¤ν„°λ””, κ·Έ μ„Έ λ²μ§Έ ν¬μ¤νΈ

# π“ λ©μ°¨

> - π”Έ ITEM 18: λ°λ“μ‹ ν•„μ”ν• μ μ•½ μ΅°κ±΄λ§ μ„¤μ •ν•λΌ.
> - π”Έ ITEM 19: λ°νƒ€μ„μ— νƒ€μ…μ„ ν™•μΈν•μ—¬ μµμ μ μ•κ³ λ¦¬μ¦μ„ μ‚¬μ©ν•λΌ.
> - π”Έ ITEM 20: `IComparable <T>`μ™€ `IComparer <T>`λ¥Ό μ΄μ©ν•μ—¬ κ°μ²΄μ μ„ ν›„ κ΄€κ³„λ¥Ό μ •μν•λΌ.
> - π”Έ ITEM 21: νƒ€μ… λ§¤κ°λ³€μκ°€ `IDisposable`μ„ κµ¬ν„ν• κ²½μ°λ¥Ό λ€λΉ„ν•μ—¬ Generic ν΄λμ¤λ¥Ό μ‘μ„±ν•λΌ.
> - π”Έ ITEM 22. κ³µλ³€μ„±κ³Ό λ°κ³µλ³€μ„±μ„ μ§€μ›ν•λΌ.
> - π”Έ ITEM 23. νƒ€μ… λ§¤κ°λ³€μμ— λ€ν•΄ λ©”μ„λ“ μ μ•½ μ΅°κ±΄μ„ μ„¤μ •ν•λΌλ©΄ Delegateλ¥Ό ν™μ©ν•λΌ.
> - π”Έ ITEM 24. λ² μ΄μ¤ ν΄λμ¤λ‚ μΈν„°νμ΄μ¤μ— λ€ν•΄μ„ Genericμ„ νΉν™”ν•μ§€ λ§λΌ.
> - π”Έ ITEM 25. νƒ€μ… λ§¤κ°λ³€μλ΅ μΈμ¤ν„΄μ¤ ν•„λ“λ¥Ό λ§λ“¤ ν•„μ”κ°€ μ—†λ‹¤λ©΄ Generic λ©”μ„λ“λ¥Ό μ •μν•λΌ.
> - π”Έ ITEM 26. Generic μΈν„°νμ΄μ¤μ™€ Non-Generic μΈν„°νμ΄μ¤λ¥Ό ν•¨κ» κµ¬ν„ν•λΌ.
> - π”Έ ITEM 27. μΈν„°νμ΄μ¤λ” κ°„λµν μ •μν•κ³  κΈ°λ¥μ ν™•μ¥μ€ ν™•μ¥ λ©”μ„λ“λ¥Ό μ‚¬μ©ν•λΌ.
> - π”Έ ITEM 28. ν™•μ¥ λ©”μ„λ“λ¥Ό μ΄μ©ν•μ—¬ κµ¬μ²΄ν™”λ Generic νƒ€μ…μ„ κ°μ„ ν•λΌ.

<Br>

---

<br>

<a href="https://learn.microsoft.com/ko-kr/dotnet/csharp/fundamentals/types/generics"><b>μ λ„¤λ¦­(Generic)</b></a>μ΄λ€ ν•μ‹ λ§¤κ°λ³€μ(Type parameter)λ΅μ„,

ν΄λμ¤λ‚ λ©”μ„λ“λ¥Ό μ‘μ„±ν•  κ²½μ°, μ΄λ¥Ό νΈμ¶ν•κΈ° μ „κΉμ§€ λ°μ΄ν„° ν•μ‹ μ§€μ •μ„ μ—°κΈ° ν•  μ μλ„λ΅ ν•λ” κΈ°λ²•μ΄λ‹¤.

.NET λ°νƒ€μ„μ΄ Generic νƒ€μ…μ„ JIT λ°©μ‹μΌλ΅ μ»΄νμΌν•  λ• μ‹¤μ  νƒ€μ… λ§¤κ°λ³€μμ— κ°’ νƒ€μ…μ΄ μ§€μ •λλ©΄ λ‹¤μκ³Ό κ°™μ€ μΌμ΄ μΌμ–΄λ‚λ‹¤.

> <span style="color:#6848b9"><b>1.</b></span> λ‹«ν Generic νƒ€μ…μ„ ν‘ν„ν•κΈ° μ„ν• μƒλ΅μ΄ IL ν΄λμ¤λ¥Ό μƒμ„±ν•λ‹¤. Generic T μΈμκ°€ κµ¬μ²΄ νƒ€μ…μΌλ΅ λ€μ²΄λλ‹¤.
> 
> <span style="color:#6848b9"><b>2.</b></span> λ€μ²΄λ νƒ€μ…μ„ μ΄μ©ν•μ—¬ μ‹¤μ  κΈ°κ³„μ–΄ μ½”λ“λ¥Ό μ‘μ„±ν•λ‹¤.

![]({{img_url}}/img_0.jpg)
<center><span style="color:gray; display:block; margin: -30px 0px 45px 0px;">Generic λ™μ‘ κ³Όμ •</span></center>

μ–΄μ…λΈ”λ¦¬κ°€ λ΅λ“λλ” μ‹μ μ΄ μ•„λ‹λΌ λ΅λ“λ νƒ€μ…μ νΉμ • λ©”μ„λ“κ°€ μµμ΄λ΅ νΈμ¶λλ” μ‹μ μ—

νΈμ¶ λ©”μ„λ“μ— λ€ν•΄μ„λ§ JIT μ»΄νμΌμ΄ μ΄λ£¨μ–΄μ§€κ³  λ©”μ„λ“ IL μ½”λ“κ°€ κΈ°κ³„μ–΄ μ½”λ“λ΅ λ€μ²΄λλ‹¤κ³  ν•λ‹¤.

<br>

---

<br>

## π”Έ ITEM 18: λ°λ“μ‹ ν•„μ”ν• μ μ•½ μ΅°κ±΄λ§ μ„¤μ •ν•λΌ.

**Genericμ— λ€ν• μ μ•½ μ΅°κ±΄**μ€ ν΄λμ¤κ°€ μ‘μ—…μ„ μ¬λ°”λ¥΄κ² μν–‰ν•κΈ° μ„ν•΄μ„

GenericμΌλ΅ μ „λ‹¬ν•  μ μλ” νƒ€μ…μ μ ν•μ„ μ ν•ν•λ” λ°©λ²•μ΄λ‹¤. *( Where κµ¬λ¬Έ )*

λ¬Όλ΅  μ΄λ° μ΅°κ±΄μ„ μ„¤μ •ν•λ” λ€μ‹ , Castingμ΄λ‚ λ°νƒ€μ„μ— ν…μ¤νΈλ¥Ό μν–‰ν•λ„λ΅ μ‘μ„±ν•  μλ„ μλ‹¤. 

κ·Έλ¬λ‚ μ μ•½ μ΅°κ±΄μΌλ΅ μ‘μ„±ν•λ©΄ λ°νƒ€μ„μ— λ°μƒν•  κ°€λ¥μ„±μ΄ μλ” μ¤λ¥λ¥Ό μ»΄νμΌνƒ€μ„μ— ν™•μΈν•  μ μκ³  μ½”λ“ λν• λ§¤μ° μ§§μ•„μ§„λ‹¤.

μλ¥Ό λ“¤λ©΄, ν…μ¤νΈ κΈ°λ°μ μ½”λ“λ” μ•„λμ™€ κ°™λ‹¤.

``` cs
// ν•λ³€ν™μ΄λ‚ λ°νƒ€μ„μ— ν…μ¤νΈ μν–‰
public static bool AreEqual<T>(T left, T right)
{
    if (left == null)
        return right == null;
    if (left is IComparable<T>)
    {
        IComparable<T> lval = left as IComparable<T>;
        if (right is IComparable<T>)
            return lval.CompareTo(right) == 0;
        else
            throw new ArgumentException("Type does not implement IComparable<T>", nameof(right));
    }
    else // μ‹¤ν¨
    {
        throw new ArgumentException("Type does not implement IComparable<T>", nameof(left));
    }
}
```

μ΄λ ‡κ² κΈ΄ μ½”λ“λ¥Ό μ μ•½ μ΅°κ±΄μ„ ν†µν•΄ λ‹¤μκ³Ό κ°™μ΄ μ‘μ„±ν•  μ μλ‹¤.

``` cs
// μ μ•½ μ΅°κ±΄ (μ»΄νμΌ λ‹¨κ³„μ—μ„λ„ μ• μ μμ)
public static bool AreEqual2<T>(T left, T right)
    where T : IComparable<T> => left.CompareTo(right) == 0;
```

<br>

μ΄μ²λΌ λ‹¤μ–‘ν• μ¥μ μ΄ μμ§€λ§ μ μ•½ μ΅°κ±΄μ„ κ³Όλ„ν•κ² μ„¤μ •ν•λ” κ²ƒμ€ μΆ‹μ§€ μ•λ‹¤.

λ§μ€ μ μ•½ μ΅°κ±΄μ„ μ‚¬μ©ν•λ©΄ Generic νƒ€μ…μ„ μ‚¬μ©ν•λ” κ²ƒμ΄ ν° λ¶€λ‹΄μ΄ λκ³ , 

μ¤νλ ¤ μ¶”κ°€ μ‘μ—…μ„ μν–‰ν•¨μΌλ΅μ¨ λ” λ³µμ΅ν•΄μ§ μ μκΈ° λ•λ¬Έμ΄λ‹¤.

<br>

κ·Έλ ‡λ‹¤λ©΄ μ–΄λ–»κ² μ μ•½ μ΅°κ±΄μ„ μ¤„μ—¬μ•Ό ν• κΉ?

* Generic νƒ€μ… λ‚΄μ—μ„ λ°λ“μ‹ ν•„μ”ν• κΈ°λ¥λ§μ„ μ μ•½ μ΅°κ±΄μΌλ΅ μ„¤μ •ν•λ‹¤.

* μ›ν•λ” λ©”μ„λ“κ°€ κµ¬ν„λμ–΄ μμ§€ μ•μ„ λ• λ°νƒ€μ„μ— νΉμ • μΈν„°νμ΄μ¤λ¥Ό κµ¬ν„ν•κ³  μλ”μ§€ νΉμ€ νΉμ • λ² μ΄μ¤ ν΄λμ¤λ¥Ό μƒμ†ν• νƒ€μ…μΈμ§€ ν™•μΈν•λ” κ²ƒμ΄ μΆ‹μ€ κ²½μ°λ„ μλ‹¤.


<br>

---

<br>

## π”Έ ITEM 19: λ°νƒ€μ„μ— νƒ€μ…μ„ ν™•μΈν•μ—¬ μµμ μ μ•κ³ λ¦¬μ¦μ„ μ‚¬μ©ν•λΌ.

Generic νƒ€μ…μ κ²½μ° νƒ€μ… λ§¤κ°λ³€μμ— μƒλ΅μ΄ νƒ€μ…μ„ μ§€μ •ν•μ—¬ μ†μ‰½κ² μ¬μ‚¬μ©ν•  μ μλ‹¤.

ν•μ§€λ§, νƒ€μ…μ΄λ‚ λ©”μ„λ“λ¥Ό Genericν™”ν•λ©΄ κµ¬μ²΄μ μΈ νƒ€μ…μ΄ μ£Όλ” μ¥μ μ„ μƒμ–΄λ²„λ¦¬κ² λλ©°,

ν•΄λ‹Ή νƒ€μ…μ μ„Έλ¶€μ μΈ νΉμ„±κΉμ§€ κ³ λ ¤ν•μ—¬ μµμ ν™”ν• μ•κ³ λ¦¬μ¦μ„ μ‚¬μ©ν•  μ μ—†κ² λλ‹¤.

<br>

λ§μ•½ μ–΄λ–¤ μ•κ³ λ¦¬μ¦μ΄ νΉμ • νƒ€μ…μ— λ€ν•΄ λ” ν¨μ¨μ μΌλ΅ λ™μ‘ν•λ‹¤κ³  μƒκ°λλ©΄ κ·Έλƒ¥ κ·Έ νƒ€μ…μ„ μ΄μ©ν•΄λ„ λλ‹¤. 

μλ¥Όλ“¤μ–΄, μ—­μν λ°©μ‹μ„ μ κ³µν•λ” `ReverseEnumerater`μ™€ `ReverseEnumerable`μ„ μ„¤κ³„ν•λ‹¤κ³  κ°€μ •ν•μ.

``` cs
public sealed class ReverseEnumerable<T> : IEnumerable<T>
{
    private IEnumerable<T> srcSequence;
    private IList<T> originalSequence;
    
    public ReverseEnumerable(IEnumerable<T> sequence)
    {
        srcSequence = sequence;
    }
    
    // IEnumerableμ μΈν„°νμ΄μ¤
    public IEnumerator<T> GetEnumerator()
    {
        if(originalSequence == null)
        {
            originalSequence = new List<T>();
            foreach (T item in srcSequence)
                originalSequence.Add(item);
        }

        return new ReverseEnumerator(originalSequence);
    }

    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => this.GetEnumerator();

    private class ReverseEnumerator : IEnumerator<T>
    {
        int currentIdx;
        IList<T> collection;

        public ReverseEnumerator(IList<T> srcCollection)
        {
            collection = srcCollection;
            currentIdx = collection.Count;
        }

        public T Current => collection[currentIdx];

        object System.Collections.IEnumerator.Current => this.Current;

        // IEnumerator<T>μ™€ IDisposable μΈν„°νμ΄μ¤λ¥Ό κµ¬ν„ν•λ‹¤.
        public void Dispose() { }
        public bool MoveNext() => --currentIdx >= 0;
        public void Reset() => currentIdx = collection.Count;
    }
}
```

<br>

μ—¬κΈ°μ„, `ReverseEnumerable`μ΄ `GetEnumerator`λ¥Ό νΈμ¶ν•  λ• 

`origianlSequence`λ¥Ό μƒλ΅ μƒμ„±ν•΄μ•Όν–λ”λ°, λ§μ•½ μ „λ‹¬λ `IEnumerable<T>`κ°€ `IList<T>`μΈ κ²ƒμ΄ ν™•μΈλλ©΄

μƒλ΅ μƒμ„± λΉ„μ©μ—†μ΄ κ·Έλ€λ΅ μ‚¬μ©ν•  μ μμ„ κ²ƒμ΄λ©° μ•„λ‹ κ²½μ°μ—λ§ μƒλ΅ μƒμ„±ν•λ©΄ λ  κ²ƒμ΄λ‹¤.

<br>

λ”°λΌμ„, λ‹¤μκ³Ό κ°™μ΄ μƒμ„±μλ¥Ό λ‹¤λ“¬μ„ μ μλ‹¤.

``` cs
public ReverseEnumerable(IEnumerable<T> sequence)
{
    srcSequence = sequence;

    // νƒ€μ…μ„ ν™•μΈν•μ—¬ κ°€λ¥ν•λ©΄ μ»¬λ ‰μ…μ„ κ°€μ Έλ‹¤ μ‚¬μ©ν•  μ μμ„ κ²ƒμ΄λ‹¤.
    originalSequence = sequence as IList<T>;
}

// μ΄λ―Έ List<T>λ΅ ν™•μΈλ νƒ€μ…μ€ νƒ€μ…μ„ ν™•μΈν•  ν•„μ”κ°€ μ—†λ‹¤.
public ReverseEnumerable(List<T> sequence)
{
    srcSequence = sequence;
    originalSequence = sequence;
}
```

<Br>

---

<br>

## π”Έ ITEM 20: `IComparable <T>`μ™€ `IComparer <T>`λ¥Ό μ΄μ©ν•μ—¬ κ°μ²΄μ μ„ ν›„ κ΄€κ³„λ¥Ό μ •μν•λΌ.

`IComparable` μΈν„°νμ΄μ¤λ¥Ό κµ¬ν„ν•λ©΄ ν•΄λ‹Ή ν΄λμ¤ μΈμ¤ν„΄μ¤κ°„μ μ„ ν›„ κ΄€κ³„λ¥Ό μ• μ μλ‹¤. 

ν•΄λ‹Ή μ„ ν›„ κ΄€κ³„λ” ν•΄λ‹Ή ν΄λμ¤λ¥Ό μ‚¬μ©ν•λ” μ»¬λ ‰μ…μ„ μ •λ ¬ν•  λ• μ‚¬μ©ν•κ² λλ‹¤.

<br>

`IComparable` μΈν„°νμ΄μ¤μ—λ” `CompareTo()` λ©”μ„λ“λ§ μ •μλμ–΄ μλ”λ°,

`Compare()`λ” ν„μ¬ κ°μ²΄κ°€ λ€μƒ κ°μ²΄λ³΄λ‹¤ μ‘μΌλ©΄ 0λ³΄λ‹¤ μ‘μ€ κ°’μ„, κ°™μΌλ©΄ 0μ„, ν¬λ©΄ 0λ³΄λ‹¤ ν° κ°’μ„ λ°ν™ν•λ‹¤.

*ν•­μƒ ν—·κ°λ¦¬λ” λ¶€λ¶„μ΄λ‹¤.*

<br>

`IComparable`μ„ κµ¬ν„ν•  λ•, λ‹¤μ 2κ°€μ§€ μ‚¬ν•­μ„ κΈ°μ–µν•΄μ•Ό ν•λ‹¤.

> * .NET ν™κ²½μ΄ μ κ³µν•λ” μµμ‹  APIλ” `IComparable <T>`λ¥Ό μ‚¬μ©ν•μ§€λ§ μΌλ¶€ μ¤λλ APIλ” μ—¬μ „ν `IComparable`μ„ μ‚¬μ©ν•κΈ° λ•λ¬Έμ— `IComparable <T>`λ¥Ό κµ¬ν„ν•  λ•λ” `IComparable`λ„ ν•¨κ» κµ¬ν„ν•΄μ•Ό ν•λ‹¤.
> 
> * `IComparable`μ„ κµ¬ν„ν•  λ•λ” κ΄€κ³„ μ—°μ‚°μλ„ ν•¨κ» μ¤λ²„λ΅λ”©ν•μ—¬ μΌκ΄€λ κ²°κ³Όλ¥Ό μ κ³µν•΄μ•Ό ν•λ‹¤.

<br>

μλ¥Ό λ“¤λ©΄, λ‹¤μκ³Ό κ°™λ‹¤.

``` cs
// IComparable<T>μ™€ IComparable λ¨λ‘ κµ¬ν„
public struct Customer : IComparable<Customer>, IComparable
{
    private readonly string name;

    // IComparable<Customer> λ©¤λ²„
    public int CompareTo(Customer other) => name.CompareTo(other.name);

    // IComparable λ©¤λ²„
    int IComparable.CompareTo(object obj)
    {
        if (!(obj is Customer))
            throw new ArgumentException("Argument is not a Customer", "obj");

        Customer other = (Customer)obj;

        return this.CompareTo(other);
    }
}
```

μ—°μ‚°μλ¥Ό μ¤λ²„λ΅λ”© ν•λ” μ½”λ“λ” λ‹¤μκ³Ό κ°™λ‹¤.

``` cs
public static bool operator <(Customer left, Customer right) => left.CompareTo(right) < 0;
public static bool operator >(Customer left, Customer right) => left.CompareTo(right) > 0;
public static bool operator <=(Customer left, Customer right) => left.CompareTo(right) <= 0;
public static bool operator >=(Customer left, Customer right) => left.CompareTo(right) >= 0;
```

<Br>

---

<br>

## π”Έ ITEM 21: νƒ€μ… λ§¤κ°λ³€μκ°€ `IDisposable`μ„ κµ¬ν„ν• κ²½μ°λ¥Ό λ€λΉ„ν•μ—¬ Generic ν΄λμ¤λ¥Ό μ‘μ„±ν•λΌ.

νƒ€μ… λ§¤κ°λ³€μλ΅ μ§€μ •ν•λ” νƒ€μ…μ΄ `IDisposable`μ„ κµ¬ν„ν•κ³  μλ‹¤λ©΄ νΉλ³„ν• μ¶”κ°€ μ‘μ—…μ΄ λ°λ“μ‹ ν•„μ”ν•λ‹¤.

μλ¥Ό λ“¤μ–΄ Generic λ©”μ„λ“ λ‚΄μ—μ„ νƒ€μ… λ§¤κ°λ³€μλ΅ μ£Όμ–΄μ§€λ” νƒ€μ…μ„ μ΄μ©ν•μ—¬ μΈμ¤ν„΄μ¤λ¥Ό μƒμ„±ν•  κ²½μ°μ— λ°μƒν•λ‹¤.

`T`κ°€ `IDisposable`μ„ κµ¬ν„ν•  νƒ€μ…μΌ κ²½μ° *(λΉ„κ΄€λ¦¬ μμ›μΌ κ²½μ°)* λ¦¬μ†μ¤ λ„μκ°€ λ°μƒν•  μ μμΌλ―€λ΅ μ¶”κ°€μ μΈ μ²λ¦¬κ°€ ν•„μ”ν•λ‹¤.

<br>

νƒ€μ… λ§¤κ°λ³€μλ΅ μ£Όμ–΄μ§„ νƒ€μ…μ„ μ΄μ©ν•μ—¬ μΈμ¤ν„΄μ¤λ¥Ό μƒμ„±ν•λ‹¤λ©΄ **λ°λ“μ‹ using λ¬Έ**μ„ μ‚¬μ©ν•λ”κ²ƒμ΄ μΆ‹λ‹¤.

``` cs
public class EngineDriverOne<T> where T : IEngine, new()
{
    public void GetThingsDone()
    {
        T driver = new T();
        using (driver as IDisposable)
        {
            driver.DoWork();
        }
    }
}
```

`using` ν‚¤μ›λ“λ” `IDisposable` νƒ€μ…μ— λ€ν•μ—¬ κ°μ‹Ό μ½”λ“λ¥Ό λ²—μ–΄λ‚λ©΄ `Dispose()`λ¥Ό νΈμ¶ν•λ” μ½”λ“λ¥Ό μƒμ„±ν•λ‹¤.

<Br>

---

<br>

## π”Έ ITEM 22. κ³µλ³€μ„±κ³Ό λ°κ³µλ³€μ„±μ„ μ§€μ›ν•λΌ.

> μ°Έμ΅° : [C# κ³µλ³€μ„±κ³Ό λ°κ³µλ³€μ„± Covariance / Contravariance](https://narakit.tistory.com/215)

κ³µλ³€μ„±(Convariance) / λ°κ³µλ³€μ„± (Contravariance)λ” C#μ μΈν„°νμ΄μ¤μ™€ λ€λ¦¬μμ— μ μ©λλ” 

**Generic νƒ€μ…μ ν•λ³€ν™μ— κ΄€ν• κΈ°μ¤€μ΄λ‹¤.**

μλ¥Ό λ“¤λ©΄, Base κΈ°λ° ν΄λμ¤μ™€ Derived νμƒ ν΄λμ¤κ°€ μλ‹¤ν•μ.

``` cs
public class Base {}
public class Derived : Base {}
```

<br>

### π”Ή κ³µλ³€μ„± (Convariance)

μΌλ°μ μΈ λ‹¤ν•μ„± μ°Έμ΅° ν•μ‹μ μΊμ¤ν…μ—λ„ μ‚¬μ©λλ” λ°©μ‹μΌλ΅

νμƒ νƒ€μ…μ μΈμ¤ν„΄μ¤λ¥Ό κΈ°λ° νƒ€μ…μΌλ΅ μ°Έμ΅°ν•  μ μλ‹¤.

``` cs
IEnumerable<Derived> d = new List<Derived>();
IEnumerable<Base> b = d;  // λ¬Έμ  μ—†μ
```

<br>

### π”Ή λ°κ³µλ³€μ„± (Contravariance)

λ°λ€λ΅ κΈ°λ° νƒ€μ… μΈμ¤ν„΄μ¤λ¥Ό νμƒ νƒ€μ…μΌλ΅ μ°Έμ΅°ν•λ‹¤.

μΌλ°μ μΈ λ‹¤ν•μ„± μ°Έμ΅° ν•μ‹μ—λ” μ μ©λμ§€ μ•λ”λ‹¤.

**λ€λ¦¬μ(Delegate)μ Generic νƒ€μ…μ—λ§ μ μ©λλ‹¤.**

``` cs
Action<Base> b = (target) => { Console.WriteLine(target.GetType().Name); };
Action<Derived> d = b;
d(new Derived());  // Action<Derived> dμ— Action<Base> νƒ€μ… μΈμ¤ν„΄μ¤ bλ¥Ό λ€μ…
```

λ°λ€λ΅ νƒ€μ…μ„ μ§€μ •ν•  μ μλ” μ΄μ λ” κΈ°μ΅΄ λ€λ¦¬μ νƒ€μ…μ΄ Baseμ΄κΈ° λ•λ¬Έμ΄λ‹¤.

dλ” ν•­μƒ Derived νƒ€μ… μΈμ¤ν„΄μ¤λ΅ νΈμ¶μ΄ κ°€λ¥ν•κ³  dκ°€ νΈμ¶μ‹ λ“±λ΅λ λ€λ¦¬μ bκ°€ νΈμ¶λλ‹¤.

bλ” Base νƒ€μ… μΈμ¤ν„΄μ¤λ¥Ό μΈμλ΅ λ°›κ³  Derivedλ” Base νƒ€μ…μΌλ΅ μ•μ „ν•κ² μΊμ¤ν…μ΄ κ°€λ¥ν•λ―€λ΅ 

λ¬Έμ  μ—†μ΄ Action νƒ€μ… bλ¥Ό νΈμ¶ν•  μ μλ‹¤. 

<br>

κ³µλ³€μ„±κ³Ό λ°κ³µλ³€μ„±μ„ μ§€μ›ν•λ” κ²ƒμ„ **κ°€λ³€μ„±(variant)**μ΄λΌκ³  μ§€μΉ­ν•κ³ ,

λ‘λ‹¤ μ§€μ›ν•μ§€ μ•λ”λ‹¤λ©΄ **λ¶λ³€μ„±(invariant)**μ΄λΌκ³  ν•λ‹¤.

> π“ CLRμ΄ μ κ³µν•λ” κ³µλ³€μ„±κ³Ό λ°κ³µλ³€μ„±μ νΉμ§•μ€ λ‹¤μκ³Ό κ°™λ‹¤.
> 
> * κ°€λ³€μ„± νƒ€μ…(κ³µλ³€μ„±/λ°κ³µλ³€μ„±)μ€ Generic μΈν„°νμ΄μ¤μ™€ λ€λ¦¬μ ν•μ‹μ—λ§ μ‚¬μ©λλ‹¤.
> 
> * Generic μΈν„°νμ΄μ¤ νΉμ€ λ€λ¦¬μλ” κ³µλ³€μ„±κ³Ό λ°κ³µλ³€μ„±μ„ λ¨λ‘ κ°€μ§ μ μλ‹¤.
> 
> * κ°€λ³€μ„±μ€ μ°Έμ΅° νƒ€μ…μ—λ§ μ μ©λλ―€λ΅ κ°€λ³€ νƒ€μ…μ— κ°’ νƒ€μ…μ„ μ‚¬μ©ν•λ‹¤λ©΄, λ§λ“¤μ–΄μ§„ μΈν„°νμ΄μ¤λ‚ λ€λ¦¬μλ” λ¶λ³€μ„±μ΄ λλ‹¤.

<Br>

---

<br>

## π”Έ ITEM 23. νƒ€μ… λ§¤κ°λ³€μμ— λ€ν•΄ λ©”μ„λ“ μ μ•½ μ΅°κ±΄μ„ μ„¤μ •ν•λΌλ©΄ Delegateλ¥Ό ν™μ©ν•λΌ.

νΉμ • λ©”μ„λ“λ¥Ό κµ¬ν„ν•κΈ°μ„ν•΄μ„ μΈν„°νμ΄μ¤λ¥Ό μ„¤μ •ν•κΈ°λ³΄λ‹¤,

ν•΄λ‹Ή λ©”μ„λ“λ¥Ό νΈμ¶λ¶€μ—μ„ κµ¬ν„ν•λ” κ²ƒμ΄ λ” νΈλ¦¬ν• λ•κ°€ μλ‹¤.

μλ¥Ό λ“¤λ©΄, νΉμ • λ§¤κ°λ³€μλ¥Ό λ°›λ” μƒμ„±μ μ‹ν€€μ¤ ν•¨μλ¥Ό νΈμ¶ν•  λ• νƒ€μ… μ μ•½μ΅°κ±΄μΌλ΅ `λ§¤κ°λ³€μκ°€ μλ”` μƒμ„±μλ¥Ό μ„¤μ •ν•  μ μ—†λ‹¤. 

ν•μ§€λ§ μ—¬κΈ°μ„ Delegateλ¥Ό μ‚¬μ©ν•λ©΄ μ μ•½μ„ λ‘ μ μλ‹¤. 

<br>

``` cs
public class Point
{
    public double X { get; }
    public double Y { get; }
    public Point(double x, double y)
    {
        this.X = x;
        this.Y = y;
    }
}
```

μ„ `Point`ν΄λμ¤λ” `double`νƒ€μ…μ λ§¤κ°λ³€μ λ‘ κ°λ¥Ό μ”κµ¬ν•λ” μƒμ„±μλ¥Ό κ°€μ§„λ‹¤. 

μ΄ `Point` ν΄λμ¤λ¥Ό μƒμ„±ν•  λ• ν•΄λ‹Ή λ§¤κ°λ³€μ μƒμ„±μλ¥Ό μ‚¬μ©ν•  μ μλ„λ΅ μ μ•½ν•  μ μλ‹¤. 

λ‹¤μ `Zip`λ©”μ„λ“λ” `Func<T1, T2, TResult>` λ€λ¦¬μλ¥Ό μ΄μ©ν•κ³  

μ‹¤μ  Pointλ¥Ό μƒμ„±ν•λ” `(x,y) => new Point(x,y)` λλ‹¤ ν‘ν„μ‹μ„ μ „λ‹¬ν•λ‹¤.

``` cs
public static class Utilities
{
    // Func<T1, T2, TResult> ν™μ©
    public static IEnumerable<TResult> Zip<T1, T2, TResult>(
        IEnumerable<T1> left, IEnumerable<T2> right, Func<T1, T2, TResult> generator)
    {
        IEnumerator<T1> leftSequence = left.GetEnumerator();
        IEnumerator<T2> rightSequence = right.GetEnumerator();

        while(leftSequence.MoveNext() && rightSequence.MoveNext())
        {
            yield return generator(leftSequence.Current, rightSequence.Current);
        }

        leftSequence.Dispose();
        rightSequence.Dispose();
    }
}

static void Main(string[] args)
{
    double[] xValues = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    double[] yValues = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

    // Delegate μ „λ‹¬
    List<Point> values = new List<Point>(Utilities.Zip(xValues, yValues, (x, y) => new Point(x, y)));
}
```

<Br>

---

<br>

## π”Έ ITEM 24. λ² μ΄μ¤ ν΄λμ¤λ‚ μΈν„°νμ΄μ¤μ— λ€ν•΄μ„ Genericμ„ νΉν™”ν•μ§€ λ§λΌ.

μ¤λ²„λ΅λ“λ λ©”μ„λ“κ°€ μ—¬λ¬κ°μΈ κ²½μ°, μ»΄νμΌλ¬κ°€ μ΄ μ¤‘ ν•λ‚λ¥Ό μ–΄λ–»κ² μ„ νƒν•λ”μ§€ μ •ν™•ν μ•κ³ μμ–΄μ•Ό ν•λ‹¤.

μλ»λ μ¤λ²„λΌμ΄λ“ ν•¨μκ°€ μ„ νƒλμ—μ„λ• λ©”μ„λ“ λ‚΄μ—μ„ νƒ€μ…ν™•μΈμ„ ν•μ—¬ λ°νƒ€μ„μ—λ¬λ¥Ό λ°©μ§€ν•  μ μκ² μ§€λ§,

Genericμ€ λ³Έλ λ°νƒ€μ„μ— νƒ€μ…ν™•μΈμ„ μν–‰ν•μ§€ μ•κΈ° μ„ν•΄ λ§λ“¤μ–΄μ΅λ‹¤λ” μ μ„ κΈ°μ–µν•΄μ•Όν•λ‹¤.

<Br>

Generic λ©”μ„λ“λ¥Ό νΉν™”ν•λ©΄ μ–΄λ–¤ ν•¨μκ°€ νΈμ¶λμ–΄ μ–΄λ–¤ ν–‰λ™μ„ κΈ°λ€ν•κΈ°κ°€ μ‰½μ§€ μ•λ‹¤. 

μ •ν•΄μ§„ λ°©μ‹μ΄ μμΌλ‚ Generic λ©”μ„λ“λ¥Ό μ΄μ©ν•λ” ν΄λμ¤λ¥Ό μ‚¬μ©ν•  λ• μ£Όμν•΄μ•Όν•κ³  

νμƒλ ν΄λμ¤λ¥Ό λ§λ“¤λ• ν•΄λ‹Ή Generic λ©”μ„λ“μ νΉν™”λ¥Ό κ°™μ΄ κµ¬ν„ν•΄μ•Όν•λ‹¤.

---

<br>

## π”Έ ITEM 25. νƒ€μ… λ§¤κ°λ³€μλ΅ μΈμ¤ν„΄μ¤ ν•„λ“λ¥Ό λ§λ“¤ ν•„μ”κ°€ μ—†λ‹¤λ©΄ Generic λ©”μ„λ“λ¥Ό μ •μν•λΌ.

Generic **ν΄λμ¤** μ κ²½μ° νΈμ¶μ‹λ§λ‹¤ νƒ€μ…μ„ λ…μ‹μ μΌλ΅ μ§€μ •ν•΄μ•Όν•λ‹¤.

μ΄ κ²½μ°, ν•΄λ‹Ή ν΄λμ¤λ§λ‹¤ Generic ν΄λμ¤κ°€ κµ¬ν„λμ—λ”μ§€ ν™•μΈν•΄μ•Όν•λ‹¤λ” λ‹¨μ μ΄ μλ‹¤.

<br>

ν•μ§€λ§ μΌλ° ν΄λμ¤λ‚΄μ—μ„ μ¤λ²„λ΅λ”©μ„ ν†µν•΄ Generic ν•¨μλ¥Ό κµ¬ν„ν•λ©΄

μΊμ¤ν…μ„ ν†µν• λ¬Έμ (λ°•μ‹±/μ–Έλ°•μ‹± μ¤λ²„ν—¤λ“, λ°νƒ€μ„ μ—λ¬)κ°€ λ°μƒν•μ§€ μ•λ”λ‹¤.

<br>

μ•„λ μ½”λ“μ™€ κ°™μ΄ `Utils` ν΄λμ¤μ— Generic λ©”μ„λ“λ¥Ό κµ¬ν„ν•  μ μλ‹¤.

``` cs
public static class Utils
{
  public static T Max<T>(T left,T right) => Comparer<T>.Default.Compare(left, right) < 0 ? right : left;
  public static T Min<T>(T left, T right) => Comparer<T>.Default.Compare(left, right) < 0 ? left : right;
}
```

μ»¬λ ‰μ…μ κ²½μ° λ‚΄λ¶€ μ›μ†λ¥Ό T νƒ€μ…μΌλ΅ μ μ§€ν•΄μ•Όν•κΈ° λ•λ¬Έμ— Generic ν΄λμ¤λ΅ κµ¬ν„ν•΄μ•Όν•λ” κ²ƒμ΄ λ§μ§€λ§

ν•„λ“κ°€ νƒ€μ…μ— λ”°λΌ λ‹¬λΌμ§€μ§€ μ•λ” κ²½μ° Generic ν΄λμ¤ λ€μ‹  Generic λ©”μ„λ“λ¥Ό μ‘μ„±ν•λ” κ²ƒμ„ κ³ λ ¤ν•λ‹¤.

<Br>

---

<br>

## π”Έ ITEM 26. Generic μΈν„°νμ΄μ¤μ™€ Non-Generic μΈν„°νμ΄μ¤λ¥Ό ν•¨κ» κµ¬ν„ν•λΌ

μƒλ΅μ΄ λΌμ΄λΈλ¬λ¦¬λ¥Ό κ°λ°ν•  λ•μ— Generic νƒ€μ…λΏ μ•„λ‹λΌ κ³ μ „μ μΈ λ°©μ‹λ„ ν•¨κ» μ§€μ›ν•λ©΄ λΌμ΄λΈλ¬λ¦¬μ ν™μ©λ„λ¥Ό μΆ€ λ” λ†’μΌ μ μλ‹¤.

Genericμ΄ μ•„λ‹ λ°©μ‹λ„ μ§€μ›ν•λ ¤λ©΄ λ‹¤μ μ„Έκ°€μ§€μ— λ€ν•΄μ„ Non-Generic λ°©μ‹μ„ μ§€μ›ν•΄μ•Όν•λ‹¤.

| 1 | 2 | 3 |
|:---:|:---:|:---:|
| ν΄λμ¤μ™€ μΈν„°νμ΄μ¤ | public μ†μ„± | serialize λ€μƒμ΄ λλ” μ”μ† |

<br>

κ·ΈλΌ μ–΄λ–»κ² Generic λ°©μ‹μ— Non-Generic λ°©μ‹μ„ μ¶”κ°€ν• κΉ?

``` cs
public class Name : IComparable<Name> 
{ 
    public string First { get; set; } 
    public string Last { get; set; } 
    public string Middle { get; set; } 
    
    // IComparable<Name> λ©¤λ²„ 
    public int CompareTo(Name other) 
    { 
        if (Object.ReferenceEquals(this, other)) 
        { 
            return 0; 
        } 
        if (Object.ReferenceEquals(this, null)) 
        { 
            return 1; // nullμ΄ μ•„λ‹ κ°μ²΄λ” nullλ³΄λ‹¤ ν¬λ‹¤. 
        } 
        
        int rVal = Comparer<string>.Default.Compare(Last, other.Last); 
        if (rVal != 0) 
        {
            return rVal; 
        }
        
        rVal = Comparer<string>.Default.Compare(First, other.First); 
        if (rVal != 0) 
        {
            return rVal; 
        }
        return Comparer<string>.Default.Compare(Middle, other.Middle); 
    } 
}
```

`Name`μ΄λΌλ” ν΄λμ¤μ— κ°μ²΄μ μ„ ν›„ κ΄€κ³„λ¥Ό μ •μν•λ” `IComparable<T>`μ μΈν„°νμ΄μ¤λ¥Ό μ μ©ν• μ½”λ“μ΄λ‹¤.

μµκ·Ό μ½”λ“λ§μ„ μ§€μ›ν•λ‹¤λ©΄ μ΄λ€λ΅λ„ μ¶©λ¶„ν•κ² μ§€λ§ μ΄λ² ννΈλ” Generic μ΄μ „μ— κ°λ°λ μ½”λ“λ“¤μ—κ²λ„ μ§€μ›μ΄ λλ„λ΅ μ½”λ“λ¥Ό μ§¤ μƒκ°μ΄λ‹¤.

<br>

λ”°λΌμ„ `IComparable` μΈν„°νμ΄μ¤λ„ μ¶”κ°€ν•΄λ³Ό κ²ƒμ΄λ‹¤.

``` cs
public class Name : IComparable<Name>, IComparable { 
    public string First { get; set; } 
    public string Last { get; set; } 
    public string Middle { get; set; } 
    
    // IComparable<Name> λ©¤λ²„ => μƒλµ 
    public int CompareTo(Name other) { ... } 
    
    // IComparable λ©¤λ²„ 
    int IComparable.CompareTo(object obj) 
    { 
        if (obj.GetType() != typeof(Name)) 
        {
            throw new ArgumentException("Argument is not a Name object"); 
        }
        return this.CompareTo(obj as Name); 
    } 
}
```

μ„ μ½”λ“μ—μ„ `IComparable.CompareTo(object obj)`λΌκ³  λ…μ‹μ μΌλ΅ μΈν„°νμ΄μ¤λ¥Ό κµ¬ν„ν•μ€μμ— μ£Όλ©ν•΄λ³΄μ. 

μ΄λ ‡κ² ν•λ©΄ μ‹¤μλ΅ Generic μΈν„°νμ΄μ¤ λ€μ‹  Non-Generic μΈν„°νμ΄μ¤λ¥Ό μ‚¬μ©ν•λ” κ²ƒμ„ λ°©μ§€ν•  μ μλ‹¤.

μ΄λ° μ‹μΌλ΅ μ½”λ“λ¥Ό μ‘μ„±ν•λ©΄ Non-Generic νƒ€μ…μ μΈν„°νμ΄μ¤μ— ν¬ν•¨λ λ©”μ„λ“λ¥Ό νΈμ¶ν•κΈ° μ„ν• μ μΌν• λ°©λ²•μ€

λ…μ‹μ μΌλ΅ `IComparable` μΈν„°νμ΄μ¤ μ°Έμ΅°λ¥Ό ν†µν•΄μ„ λ©”μ„λ“λ¥Ό νΈμ¶ν•λ” κ²½μ° λΏμ΄λ‹¤.

<Br>

---

<br>

## π”Έ ITEM 27. μΈν„°νμ΄μ¤λ” κ°„λµν μ •μν•κ³  κΈ°λ¥μ ν™•μ¥μ€ ν™•μ¥ λ©”μ„λ“λ¥Ό μ‚¬μ©ν•λΌ.

μΈν„°νμ΄μ¤μ—μ„ μ •μν•λ” λ©¤λ²„λ“¤μ€ μ΄λ¥Ό κµ¬ν„ν•λ” ν΄λμ¤μ—μ„ λ°λ“μ‹ κµ¬ν„ν•΄μ•Όν•λ‹¤.

λ°λ“μ‹ κµ¬ν„ν•΄μ•Όν•λ” λ©¤λ²„μ μλ” μµμ†ν•μΌλ΅ ν•κΈ° μ„ν•΄ λ…Έλ ¥ν•κ³ , ν™•μ¥ λ©”μ„λ“λ¥Ό ν†µν•΄ λ‹¤μ–‘ν• κΈ°λ¥μ„ μ κ³µν•λ” κ²ƒμ΄ μΆ‹λ‹¤.

μ¶”κ°€λ΅ ν™•μ¥ λ©”μ„λ“λ¥Ό μ΄μ©ν•λ©΄ μΈν„°νμ΄μ¤μ—μ„ μ •μλ λ©”μ„λ“μ κΈ°λ³Έ κµ¬ν„μ²΄λ¥Ό μ κ³µν•΄μ¤„ μλ„ μλ‹¤.

``` cs
// IFoo μΈν„°νμ΄μ¤
public interface IFoo
{
    int Marker { get; set; }
}

// IFoo μ ν™•μ¥ λ©”μ„λ“
public static class FooExtenstions
{
    public static void NextMarker(this IFoo thing) =>
        thing.Marker += 1;
}

// IFooμ κµ¬ν„μ²΄ MyType ν΄λμ¤
public class MyType : IFoo
{
    public int Marker { get; set; }
}

// MyType ν΄λμ¤μ—λ” NextMarker() λ©”μ„λ“κ°€ μ •μλμ–΄ μμ§€ μ•μ§€λ§ νΈμ¶ν•  μ μλ‹¤.
MyType t = new MyType();
t.Marker = 1;
t.NextMarker();
```

<Br>

---

<br>

## π”Έ ITEM 28. ν™•μ¥ λ©”μ„λ“λ¥Ό μ΄μ©ν•μ—¬ κµ¬μ²΄ν™”λ Generic νƒ€μ…μ„ κ°μ„ ν•λΌ.

ITEM 27κ³Ό λΉ„μ·ν•κ² `List`, `Dictionary<EmployeeID, Employee>`μ™€ κ°™μ΄ 

**μ΄λ―Έ κµ¬μ²΄ν™”λ μ»¬λ ‰μ… νƒ€μ…**μ— ν™•μ¥ λ©”μ„λ“λ¥Ό μ¶”κ°€ν•μ—¬ μƒλ΅μ΄ κΈ°λ¥μ„ μ¶”κ°€ν•  μ μλ‹¤.

μμ‹λ΅, `System.Linq.Enumerable` ν΄λμ¤λ” νΉμ • `IEnumerable` νƒ€μ…μ— λ€ν• ν™•μ¥ λ©”μ„λ“λ“¤μ΄ μ •μλμ–΄ μλ‹¤.

``` cs
public static class Enumerable
{
    public static int Average(this IEnumerable<int> sequnece);
    public static int Max(this IEnumerable<int> sequence);
    public static int Min(this IEnumerable<int> sequence);
    public static int Sum(this IEnumerable<int> sequence);

    // λ‹¤λ¥Έ λ©”μ„λ“ μƒλµ
}
```

### π”Ή ν™•μ¥ λ©”μ„λ“λ¥Ό μ‚¬μ©ν–μ„ λ–„μ μ¥μ 

1. λ‹¨μν• κΈ°λ¥μ„μ κ³µν•λ” λ©”μ„λ“λ¥Ό λ‹¤μ–‘ν•κ² μ¬μ‚¬μ©ν•  μ μλ‹¤.

2. μ»¬λ ‰μ… κ³ μ μ μ €μ¥μ† λ¨λΈκ³Ό λ¬΄κ΄€ν•κ² κΈ°λ¥μ„ κµ¬ν„ν•  μ μλ‹¤. *(`IEnumerable`` λ“± μ‚¬μ©)*

<br>
<br>
