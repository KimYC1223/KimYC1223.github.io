---
layout: post
pagination: 
  enabled: true
type: tech
date: 2025-10-06 15:35
category: Blog
title: "Unity 보안 취약점 이슈 살펴보기"
subtitle: "2025년 10월에 발생한 CVE-2025-59489 유니티 보안 취약점 이슈에 대해 살펴보도록 한다."
writer: KimYC1223
post-header: true
image: title.png
header-img: bg.png
tags: [Unity]
draft : false
---

{% capture img_url %}/assets/blog/{{page.date | date: "%Y-%m-%d"}}-TechPost{% endcapture %}

2025년 10월에 발생한 <b>CVE-2025-59489 보안 이슈</b>에 대해 살펴보도록 한다.

---

즐거운 추석 연휴가 시작되는 2025년 10월, 연휴 시작과 동시에 발생한 `CVE-2025-59489` 보안 이슈에 대해 살펴보도록 하자.

여느떄와 다름없던 어느 날, Unity 계정으로 등록된 메일 주소로 다음과 같은 <span class="post-highlight">Unity 플랫폼 보호: 게임과 앱 보호를 위해 즉시 조치가 필요합니다.</span> 라는 메일이 한통 도착했다.

<center>
<img src="{{img_url}}/img_01.png" style="max-width:428px; width:100%; border:1px solid #000000; padding: 20px">
<figcaption style="margin-top:-30px;">Unity로 부터 도착한 보안 관련 공지</figcaption>
</center>

처음에는 내가 뭘 잘못해서 이런 메일을 받은줄 알았는데, 그런건 딱히 아니었고 Unity 엔진 자체에서 보안 이슈가 터진듯 했다. 

<center>
<img src="{{img_url}}/img_00.gif" style="max-width:300px; width:100%;">
<figcaption style="margin-top:-20px;">처음에는 내 잘못인줄 알았다</figcaption>
</center>

해당 보안 이슈는 `GMO Flatt Security` 사의 연구원 `RyotaK` 가 올해 6월에 찾았다고 알려졌다고 하는데, <b>정확히 이게 무슨 일이지?</b> 하고 살펴 보던 도중, 메일의 최하단부에 다음과 같은 문구를 발견했다.

<br />

<div style="background-color:#F5F5F5; padding: 15px 20px; border-radius: 10px">
<b>유니티의 책임</b> : 유니티는 플랫폼과 고객, 커뮤니티의 보안과 무결성을 위해 노력하고 있습니다. 투명한 커뮤니케이션은 이러한 노력의 핵심이며, 필요에 따라 지속적으로 업데이트를 제공할 예정입니다.<br />
<br />
기술과 관련된 종합적인 세부 정보는 <b>패치 툴 및 문제 해결 가이드</b>, <b>보안 권고</b>, <b>CVE-2025-59489</b>를 참고하시기 바랍니다. 
</div>

<br />

이 중 눈에 띄었던 것은 `CVE-2025-59489` 였다. 구글링을 해본 결과, 마침 이 이슈를 발견한 `GMO Flatt Security` 사의 <a href="https://flatt.tech/research/posts/arbitrary-code-execution-in-unity-runtime/">리서치 포스트</a>에서 관련 내용을 찾을 수 있었다.

본 포스트에서는 해당 리서치를 톺아보도록 한다.

<br />

* 📗 **참고 자료**
    * [CVE-2025-59489: Arbitrary Code Execution in Unity Runtime](https://flatt.tech/research/posts/arbitrary-code-execution-in-unity-runtime/)
    * [월요신문 : 유니티 엔진에서 보안 취약점 발견...게임업계 '혼란'](https://www.wolyo.co.kr/news/articleView.html?idxno=302183)

---

<div style="background-color:#FFD2D2; padding: 10px 20px; border-radius: 10px; width:100%; position: relative;">
<div style="position:absolute; font-size:24px;">❓</div>
<div style="padding-left:50px; width:calc(100% - 50px);">
<b><span style="line-height:32px;">바쁜 현대인을 위한 한 줄 요약</span></b><br />Unity 2017.1f 이상을 사용하고 있나요? 그럼 Unity Hub를 최신으로 받고 에디터를 업데이트 하세요!
</div>
</div>

# 🔷 톺아보기

본 이슈는 정리하면 <span class="post-highlight">Unity 런타임의 인텐트 처리 프로세스</span>에서 취약점이 발견되었다는 내용이다. 

그럼 여기서 `인텐트 (Intent)`란 무엇일까?

<br />

## 🔶 Intent가 뭐지?

<b>`Intent`란, Android에서 컴포넌트 간의 메시지를 전달하기 위한 핵심 메커니즘이다.</b> 앱 내부의 Activity 간 이동뿐 아니라, 외부 앱(예: 브라우저, 카메라, 전화 앱 등)과의 상호작용까지 모두 이 객체를 통해 이루어진다. 이름 그대로 <span class="post-highlight">의도(Intent)</span>를 표현하는 객체로, 개발자는 이를 통해 `무엇을 할지(Action)`와 `무엇에 대해 할지(Data)`를 명시하여 시스템에 요청할 수 있다.

예를 들어, 다음 코드처럼 `Intent.ACTION_VIEW`와 URL 데이터를 지정하면 브라우저를 통해 해당 웹페이지를 열 수 있다. <i>(Kotlin 코드이다.)</i>

``` kotlin
val intent = Intent(Intent.ACTION_VIEW, Uri.parse("https://KimYC1223.github.io"))
startActivity(intent)
```

<br />

Intent에는 명시적 인텐트(Explicit Intent)와 암시적 인텐트(Implicit Intent)가 있는데, 여기서는 너무 내용이 깊어지므로 설명하지 않도록 한다. 아래는 Implicit Intent가 동작하는 방식을 설명하는 그림이다.

<center>
<img src="{{img_url}}/img_02.png" style="max-width:429px; width:100%;">
<figcaption style="margin-top:-20px;">시스템을 통해 다른 Activity를 시작하기 위해 Implicit Intent가 전달되는 방식</figcaption>
</center>

<br />

또한 Intent는 단순히 어떤 액션(Action) 을 실행하라는 요청뿐 아니라 그 요청과 함께 추가 `정보` 도 같이 보낼 수 있는데, 이걸 **extra** 라고 부른다. 

> 예를 들면, <i>**이메일 앱 열어줘**</i> 라는 액션이 있다면, <i>**받는 사람**</i>, <i>**제목**</i>, <i>**본문**</i> 같은 데이터를 extra로 담아서 보내는 것이다.

<br />

설명이 길었는데, <span class="post-highlight">Intent</span> 란, **안드로이드의 Intent는 컴포넌트 간 메시지를 전달하며, 실행할 동작(Action)과 대상(Data), 그리고 추가 정보(extra)를 함께 담아 시스템에 요청하는 핵심 메커니즘이다.** 정도만 기억하면 될 듯 하다.

<br />

---

## 🔶 Unity와 Intent

Intent에 대한 설명은 이쯤 해두고, 슬슬 이번 사안에 관한 내용을 살펴 보도록 하자. 

<a href="https://docs.unity3d.com/6000.0/Documentation/Manual/android-custom-activity-command-line.html">Unity Documents</a>에 따르면, Android OS에서는 Unity 애플리케이션의 디버깅을 지원하기 위해 <b>unity extra</b>를 포함한 인텐트를 처리하는 핸들러를 `UnityPlayerActivity` 에 자동으로 추가하게 된다고 한다. 이때, `UnityPlayerActivity` 는 애플리케이션의 기본 진입점 역할을 하며, 다른 앱에서도 접근할 수 있도록 export된다.

예를 들어, Android에서 다음과 같이 `-systemallocator` 라는 extra와 함께 게임을 실행시킬 수 있다는 뜻이다.

``` shell
adb shell am start -n "com.Company.MyGame/com.unity3d.player.UnityPlayerActivity" -e unity "-systemallocator"
```

<br />

알다시피 Unity 엔진은 일반적으로 PC용 실행 환경처럼 명령줄 인자를 받을 수 있다. <i>( [-force-vulkan](https://docs.unity3d.com/es/2021.1/Manual/CommandLineArguments.html) 같은 설정 )</i> 그런데 Android 쪽에선 이런 명령줄 인자를 직접 줄 수 없으므로, Unity에서는 이 `-e unity`를 명령줄 인자 대체 수단으로 쓴 것이라고 한다.

이런 Intent와 extra를 사용한다면 동작 흐름은 대략 이렇게 된다고 보면 된다.

<div style="background-color:#F5F5F5; padding: 15px 20px; border-radius: 10px"><ol>
<li>앱을 실행할 때, Intent 생성자나 <b>am start -e unity "..."</b> 처럼 Intent의 extra에 <b>"unity"</b> 키를 넣고, 거기에 명령줄 인자 문자열을 담는다.</li>
<li><b>UnityPlayerActivity</b> <i>(Unity가 Android에서 기본으로 쓰는 Activity)</i>가 이 Intent를 받는다.</li>
<li>내부 코드에서 <b>getIntent().getStringExtra("unity")</b> 함수를 통해 extra 값을 읽는다.</li>
<li>읽은 문자열을 Unity 런타임 초기화 시점에 명령줄 인자처럼 해석해서 엔진 쪽에 넘긴다.</li></ol>
</div><br />

실제로 `UnityPlayerActivity.java` 를 확인해보면 다음과 같은 부분이 있음을 알 수 있다.

``` java
// Setup activity layout
@Override protected void onCreate(Bundle savedInstanceState)
{
    // ...

    String cmdLine = updateUnityCommandLineArguments(getIntent().getStringExtra("unity"));

    // ...
}
```

<div style="background-color:#ddf4fc; padding: 10px 20px; border-radius: 10px; width:100%; position: relative;">
<div style="position:absolute; font-size:24px;">🔍</div>
<div style="padding-left:50px; width:calc(100% - 50px);">
<b><span style="line-height:32px;"><span class="post-highlight">UnityPlayerActivity</span>을 직접 확인해보고 싶은가?</span></b><br /><i>( Windows 기준, 기본 설치 경로에 Unity Hub 설치했다고 한다면 )</i> <code class="language-plaintext highlighter-rouge" style="color: #628eaaff !important; background-color: rgba(1,1,1,0.1) !important;">C:\Program Files \ Unity \ Hub \ Editor \ 유니티버전 \ Editor \ Data \ PlaybackEngines \ AndroidPlayer \ Source \ com \ unity3d \ player</code> 에 있는  <code class="language-plaintext highlighter-rouge" style="color: #628eaaff !important; background-color: rgba(1,1,1,0.1) !important;">UnityPlayerActivity.java</code> 를 보면 된다!
</div>
</div>

<br />

---

## 🔶 CVE-2025-59489 : Unity 런타임에서 임의 코드 실행

근데 <b>왜 이게 왜 문제</b>가 될까? 바로 <b>지금까진 Unity에서 이 Intent에 대해 특별히 검사를 하지 않았기 때문</b>이다.

> While Android’s permission model manages feature access by granting permissions to applications, it does not restrict which intents can be sent to an application.
> This means any application can send the unity extra to a Unity application, allowing attackers to control the command line arguments passed to that application

> 안드로이드의 권한 모델은 애플리케이션에 권한을 부여하여 기능 액세스를 관리하지만, 애플리케이션에 전송할 수 있는 인텐트는 제한하지 않습니다.
> 즉, 모든 애플리케이션이 Unity Extra를 Unity 애플리케이션으로 전송할 수 있으며, 이를 통해 공격자는 해당 애플리케이션에 전달되는 명령줄 인수를 제어할 수 있습니다.

<br />

Android에는 <span class="post-highlight">Permission</span>이라는 것이 있다. 말 그대로 `권한`으로, 앱이 기기 내의 민감한 자원이나 기능 <i>( 예: 카메라, 위치, 연락처, 파일 저장소 등 )</i> 에 접근하기 위해 사용자에게 명시적으로 허용을 받아야 하는 시스템 메커니즘으로, 보안을 위해 OS단위에서 앱이 접근 가능한 범위를 엄격히 제한하며, 사용자 동의 없이는 개인정보나 시스템 리소스에 접근할 수 없도록 하는 것이다.

<center>
<img src="{{img_url}}/img_03.svg" style="max-width:250px; width:100%;">
<figcaption style="margin-top:-25px;">Android에서 Permission을 요청하는 팝업</figcaption>
</center>

이는 주로 Manifest에서 미리 선언해두거나, 런타임에서 사용자에게 요청하는 식으로 받아올 수 있다.

``` xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android" package=" ... " >
    <!-- ... -->

    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />

    <!-- ... -->
</manifest>
```

하지만 이렇게 Permission을 엄격하게 관리하고 있는 반면, Intent 자체는 별도의 제한을 하고 있지 않기 때문에 다른 앱이 Unity에게 악의적인 Intent를 보낼 수 있다는 뜻이다.

<br />

그럼 여기서 다시, <b>다른 앱이 Unity에게 악의적인 Intent를 보낼 수 있다는건 왜 문제가 될까?</b> 이 질문에 답을 하려면, `RyotaK` 씨가 발견한 취약점을 살펴 봐야 한다.

<br />

`RyotaK` 씨는 Unity 빌드 파일을 Ghidra로 분석을 해본 결과, 다음과 같은 코드를 찾아냈다고 한다. 

``` cpp
initLibPath = FUN_00272540(uVar5, "xrsdk-pre-init-library");
```

> 여기서 **Ghidra란 역어셈블러 프레임워크**라고 한다. 조금 찾아보니 Ghidra를 사용해서 유니티 빌드를 분석한 국내 [포스트](https://devmae.tistory.com/459)도 찾을 수 있었다.

<br />

그리고 이 값은 나중에 `dlopen` 에 전달되어 <span style="color:red;"><b>xrsdk-pre-init-library 에 지정된 경로가 네이티브 라이브러리로 로드되도록 한다고 한다!</b></span>

``` cpp
lVar2 = dlopen(initLibPath, 2);  
```

<br />

이런 로직을 통해 악의적인 의도를 가진 사용자가 `-xrsdk-pre-init-library` 인수에 특정 공유 라이브러리 <b><i>( .so 파일 )</i></b>를 로드하고 악성 코드를 실행할 수 있다는 것이다.

이때 실행되는 코드는 Unity의 컨텍스트에서 실행되므로, <span style="color:red;"><b>Unity의 Permission으로 실행된다!</b></span>

<br />

> [Unity 개발자 문제 해결 가이드](https://unity.com/security/sept-2025-01/remediation)의 설명에 따르면, `-xrsdk-pre-init-library`는 Unity가 실행될 때 내부 설정 파일 <i>( Data/boot.config )</i> 에서 불러와야 하는 인자가 있는데, 이 인자는 Unity가 실행 시 네이티브 라이브러리를 로드하도록 하는 역할을 한다. 하지만 이 인자는 커맨드 라인 인자로 사용하도록 설계된 것이 아니라고 한다.

<br />

---

## 🔶 공격 시나리오

그럼 실제로 이걸 이용해서 나쁜짓을 하려면 어떻게 해야할까? 다음과 같은 시나리오가 가능할 수 있다.

<br />

### 💠 Local Attack

악의적인 의도를 가진 앱을 만든다면, 다음과 같이 공격을 할 수 있다.

1. `AndroidManifest.xml` 에서 `android:extractNativeLibs` 속성을 `true`로 설정하여 네이티브 라이브러리를 추출한다. <i>( 이 네이티브 라이브러리에는 나쁜짓(?)을 할 수 있는 코드가 포함되어 있다. )</i>
2. 그리고, Intent에 `-xrsdk-pre-init-library` 인수로 악성 라이브러리를 지정하여 Unity 앱을 실행한다.
3. 그러면 Unity 앱의 권한을 가지고 악성 코드를 로드하고 실행하게 된다.

<br/>

물론 이 공격이 성공하려면, 악의적인 의도를 가진 앱과 Unity가 같은 기기에 설치되어 있어야 하고, Unity앱이 나쁜짓에 필요한 권한을 가지고 있어야 한다.

<br />

### 💠 Remote Attack

웹 브라우저를 사용해서, 링크를 눌렀을 때 비슷한 동작을 하게 만들수 도 있다.

Unity 앱이 `android.intent.category.BROWSABLE` 카테고리 <i>( 브라우저 실행 허용 )</i>를 사용하는 경우, 악성 웹사이트에서 <span class="post-highlight">Intent URL</span>을 사용하여 Activity에 전달되는 추가 기능을 지정할 수 있다.

``` javascript
intent:#Intent;package=com.example.unitygame;scheme=custom-scheme;S.unity=-xrsdk-pre-init-library%20/data/local/tmp/malicious.so;end;
```

즉, 사용자가 `/data/local/tmp/malicious.so` 파일을 다운로드 받게 만든 후, 해당 Intent URL을 호출하면 Unity 앱이 켜지면서 `malicious.so` 가 실행되어 나쁜짓을 하게 되는 것이다!

<br />

하지만 안드로이드의 엄격한 [SELinux 정책](https://www.redhat.com/ko/topics/linux/what-is-selinux)은 `dlopen`이 다운로드 디렉터리의 파일을 열지 못하도록 차단하여 거의 모든 원격 악용 시나리오를 막게 된다. 🫤

``` bash
library "/sdcard/Download/libtest.so" ("/storage/emulated/0/Download/libtest.so") needed 
or dlopened by "/data/app/~~24UwD8jnw7asNjRwx1MOBg==/com.DefaultCompany.com.unity.template. 
mobile2D-E043IptGJDwcTqq56BocIA==/lib/arm64/libunity.so" is not accessible for the 
namespace: [name="clns-9", ld_library_paths="",default_library_paths="/data/app/~~24UwD8jnw7asNjRwx1MOBg==/com.DefaultCompany.com.unity.template. 
mobile2D-E043IptGJDwcTqq56BocIA==/lib/arm64:/data/app/~~24UwD8jnw7asNjRwx1MOBg==/com.DefaultCompany.com.unity.template.mobile2D-E043IptGJDwcTqq56BocIA==/base.apk!/lib/arm64-v8a", permitted_paths="/data:/mnt/expand:/data/data/com.DefaultCompany.com.unity.template.mobile2D"]
```

이때 주의할 점은, `/data/` 디렉터리는 `permitified_paths`에 포함되어 있으므로 Unity 앱이 `Internal Storage`에 파일을 쓰는 경우 이 제한을 우회하는 데 사용될 수 있게 된다는 점이다.

<br />

즉, 다음과 같은 2가지 조건을 만족하면 브라우저를 통한 공격에 취약하다는 뜻이다.

* Unity 앱이 `android.intent.category.BROWSABLE` 카테고리를 사용하며, UnityPlayerActivity 또는 UnityPlayerGameActivity를 진입점으로 빌드 하는 경우
* Unity 앱이 `Internal Storage`에 파일을 읽고 쓰는 경우

<br />

물론 이 2가지 조건을 만족하지 않는다 하더라도, `Local Attack` 에는 취약하다는 점은 기억해야 한다.

<br />

### 💠 데모 영상

아래는 `RyotaK` 씨가 올린 해당 보안 이슈의 **Remote Attack** 데모 영상이다. 로그를 자세히 보면 `HijackLib` 이 호출 된 모습을 볼 수 있다.

<style>.embed-container { position: relative; padding-bottom: 40%; height: 0; overflow: hidden; width: 100%; text-align:center; align-items:center; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; width: 600px; max-width: 100%; height: 100%; transform:translateX(-50%) !important; left:50%; display : inline-block}</style><div class='embed-container'><iframe width="560" height="315" src="https://www.youtube.com/embed/QEhqb4A_MwQ?si=ryeoXqp8XyC250H8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></div>
<figcaption style="margin-top:10px;">Unity Arbitrary Code Execution Demonstration Video</figcaption>

<br />

* 📗 **참고 자료**
    * [Unity 플랫폼 보호: 개발자 문제 해결 가이드](https://unity.com/kr/security/sept-2025-01/remediation)
    * [CVE-2025-59489: Arbitrary Code Execution in Unity Runtime](https://flatt.tech/research/posts/arbitrary-code-execution-in-unity-runtime/)
    * [Android Developer : 인텐트와 인텐트 필터](https://developer.android.com/guide/components/intents-filters?hl=ko)
    * [Android Developer : 런타임 권한 요청](https://developer.android.com/training/permissions/requesting?hl=ko)
    * [Unity Documents : Specify Android Player command-line arguments](https://docs.unity3d.com/6000.0/Documentation/Manual/android-custom-activity-command-line.html)
    * [RedHat : SELinux(Security-Enhanced Linux)란?](https://www.redhat.com/ko/topics/linux/what-is-selinux)
    * [개발자 향기 블로그 : Il2CppDumper와 ghidra로 유니티 il2cpp빌드 분석하기](https://devmae.tistory.com/459)

---

# 🔷 플랫폼 취약점 현황 및 대응 방법

여기까지 알아보고 다시 <a href="https://unity.com/kr/security/sept-2025-01/remediation">Unity 플랫폼 보호: 개발자 문제 해결 가이드</a>를 다시 읽어보았다.

`RyotaK` 씨가 찾은 문제는 Android에서만 문제가 발생했다는 것이기에 Android에서만 문제가 발생한 것인가 보다! 라고 생각했는데, Unity가 자체적으로 더 조사해서 **비슷한 문제가 있는 커맨드 라인** 을 더 찾아낸 것 같다.

일단 문제가 있는 커맨드 라인은 다음과 같다.

|커맨드 라인 | 영향을 받는 최종 릴리스 버전 |
|:---|:---|
| `xrsdk-pre-init-library` | Android, Windows, Mac, Linux: Unity 2019.1 이상 |
| `dataFolder` | Windows: Unity 2022.2 이상 Mac: Unity 2023.2 이상 Linux Unity 2022.3 이상 |
| `overrideMonoSearchPath` | Android 32-bit(mono), Windows(mono), Mac(mono), Linux(mono): Unity 2017 이상 |
| `monoProfiler` | Windows(mono): Unity 2018.3 이상 |

자세한 설명은 개발자 문제 해결 가이드를 참고하면 되는데,

여기서는 주로 모바일 환경에 대해 알아보도록 한다.

<br />

---

## 🔶 Android

* Android의 경우, 제작한 Unity 앱이 `Unity 2019.1 이상` 버전으로 빌드되었다면 어떠한 특별한 권한이나 설정에 관계없이 조치를 취해야 한다. <i>( `xrsdk-pre-init-library` )</i>

* 또한 앱이 `Unity 2017 이상` 버전으로 빌드되었고 `Mono 런타임 (32비트만 해당)` 을 사용하는 경우 취약점이 존재할 수 있다. <i>( `overrideMonoSearchPath` )</i>

* Android 앱은 `datafolder`나 `monoProfiler` 커맨드 라인 인자에 취약하지 않다.

<details style="padding: 10px 0px 0px 30px;">
<summary>보안 이슈 관련 Android 부분 수정 사항 <i>(클릭해서 펼치기)</i></summary>
<div style="background-color:#F5F5F5; padding: 15px 20px; border-radius: 10px">
Unity 애플리케이션 패치 프로그램은 xrsdk-pre-init-library 문자열을 8rsdk-pre-init-library로 변경하여 libunity.so와 boot.config 모두에서 취약한 코드 경로를 차단합니다. 이 변경으로 인해, 인자 구문 분석 방식의 특성상 커맨드 라인 인자(또는 Android의 인텐트 엑스트라)로는 사용할 수 없게 됩니다. 단, boot.config 설정에서는 여전히 동작할 수 있으므로 boot.config 파일 내에서 사용되는 내용도 함께 패치합니다.<br /><br />
또한 Unity 애플리케이션 패치 프로그램은 Mono를 사용하는 32비트 빌드에서 overrideMonoSearchPath 인수를 비활성화하며, libunity.so에서 overrideMonoSearchPath 문자열의 첫 번째 문자를 유효하지 않은 유니코드 문자 0xC0로 교체합니다.
</div>
</details>

<br />

---

## 🔶 iOS

* iOS 플랫폼에서는 취약점이 악용될 가능성이 발견되지 않았다고 한다. 다만 최고 수준의 보안을 위해, 유니티에서는 최신 패치가 적용된 Unity 에디터로 앱을 다시 빌드할 것을 권장한다.

<br />

---

## 🔶 그래서 어떻게 업데이트 하는데?

그럼 어떻게 보안 패치를 받아야 하는걸까? 개발자 가이드에 따르면 **Unity Editor를 업데이트 하거나**, **Patch Tool을 받거나**라고 하는데, 에디터를 새로 받는게 제일 간단하므로 여기서는 그 방법만 공유한다.

일단 Unity Hub를 켜보면, 다음과 같이 기분 나쁜 빨간 느낌표를 마주할 수 있다. ( 만약 뜨지 않는다면 Unity Hub를 최신 버전으로 업데이트 하라! )

<center>
<img src="{{img_url}}/img_04.png" style="max-width:910px; width:100%;">
<figcaption style="margin-top:-25px;">Unity Hub에 나타난 빨간 느낌표</figcaption>
</center>

여기서는 내가 받은 프로젝트 버전중 하나인 `6000.0.37f1` 버전을 업데이트 받아보려고 한다. 빨간 느낌표를 눌러본다.

<center>
<img src="{{img_url}}/img_05.png" style="max-width:910px; width:100%;">
<figcaption style="margin-top:-25px;">Install other Editor version 버전 클릭</figcaption>
</center>

창이 뜨면, `Install other Editor version` 버튼을 클릭한다.

<center>
<img src="{{img_url}}/img_06.png" style="max-width:910px; width:100%;">
<figcaption style="margin-top:-25px;">Archive - download archive 클릭</figcaption>
</center>

Archive 탭을 누르고, download archive 라는 링크를 눌러 Unity 다운로드 웹 아카이브 페이지로 이동한다.

<center>
<img src="{{img_url}}/img_07.png" style="max-width:851px; width:100%;">
<figcaption style="margin-top:-25px;">Download Archive에서 다운로드받기</figcaption>
</center>

자신의 버전의 `현재 쓰는 버전의 주 버전 내에서 가장 최신 패치 버전`을 다운로드 받는다. 

예를 들어, 업데이트 하고자 하는 유니티의 버전이 `6000.0.37f1` 이라면 주 버전은 `6000.0` 이므로, `6000.0.X` 버전들 중 가장 최신 버전을 받으면 된다. <i>( 2025년 10월 기준, `6000.0.58f2` 이다. )</i>

<center>
<img src="{{img_url}}/img_08.png" style="max-width:910px; width:100%;">
<figcaption style="margin-top:-25px;">빨간 느낌표 제거 성공</figcaption>
</center>

Unity 버전을 강제로 올려야 한다는 점이 매우 마음에 들지 않지만... 일단 빨간 느낌표는 없어졌다.

<br />

* 📗 **참고 자료**
    * [Unity 플랫폼 보호: 개발자 문제 해결 가이드](https://unity.com/kr/security/sept-2025-01/remediation)

---

# 🔷 마치며

갑작스럽게 보안 메일이 도착해서, 내용을 찾아보고 정리를 해 보았다.

평소 익숙하지 않은 부분이라 블로그 포스트로 작성하며 공부도 많이 됐던 것 같다!

> P.S. 급하게 작성한 글이라 잘못 찾은 정보가 있을 수 있으니, 이상하거나 잘못된 곳이 있으면 댓글로 피드백 달아주시면 감사드리겠습니다. (_ _)