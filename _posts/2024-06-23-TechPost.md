---
layout: post
pagination: 
  enabled: true
type: tech
date: 2024-06-23 11:27
category: Blog
title: Unity Coroutine과 Task의 차이 비교
subtitle: Unity에서 자주 사용하는 Coroutine과 Task, 잘 알고 써보기
writer: KimYC1223
post-header: true
header-img: bg.png
image: title.png
tags: [C_Sharp]
draft : false
---

{% capture img_url %}/assets/blog/{{page.date | date: "%Y-%m-%d"}}-TechPost{% endcapture %}

Unity에서 흔하게 사용하는 Coroutine과 Task.

그동안 너무 제대로 알지 못하고 사용한 것 같아, 오늘은 이 두 개념에 대해 상세히 조사해보는 시간을 가져보았다.

<br><br>

---

## 🔷 비동기 프로그래밍 ( Asynchronous Programming )

코딩을 하면서, **비동기 프로그래밍** ( `Asynchronous Programming` ) 이라는 말을 많이 들어보았을 것이다. 

본 주제를 진행하기 앞서, 각 항목별로 어떤 개념인지 살펴보고 가도록 하겠다.

<br>

비동기 프로그래밍은 프로그램의 실행 흐름을 비동기적으로 처리하여, 

<span class="post-highlight">하나의 작업이 완료될 때까지 기다리지 않고 다른 작업을 수행할 수 있도록 하는 프로그래밍 방식</span>이다.

<br>

비동기 프로그래밍은 현대 소프트웨어 개발에서 중요한 개념 중 하나이다. 

이는 프로그램이 여러 작업을 동시에 처리할 수 있게 하여, 효율성과 속도를 크게 향상시킬 수 있기 때문이다.

이에 관한 적절한 예시가 [MS Learn](https://learn.microsoft.com/ko-kr/dotnet/csharp/asynchronous-programming/)에 있는데, 아래와 같이 아침을 준비하는 방식에 대한 예시이다.

<div style="width:100%; float:none">
    <div style="float:left; width:25.5%; max-width:265px;">
    <center>
    <figcaption style="margin-top:20px; margin-bottom:-40px">동기 프로그래밍 방식</figcaption>
    <img src="{{img_url}}/img_3.png" style="width:100%; max-width:265px;">
    </center>
    </div>

    <div style="float:left; width:74.5%; max-width:774px; ">
    <center>
    <figcaption style="margin-top:20px; margin-bottom:-40px">비동기 프로그래밍 방식</figcaption>
    <img src="{{img_url}}/img_4.png" style="width:100%; max-width:774px;">
    </center>
    </div>
</div>
<div style="clear:both"></div>

아침 식사를 준비하기 위해 커피와 계란 후라이, 베이컨 구이, 잼 바른 토스트, 주스 한 컵이 필요하다고 했을 때,

주방이 여유롭다고 가정하면 보통 요리를 순서대로 하나씩 준비하지 않는다. 

먼저 커피를 따른 후, 계란 후라이를 하며 다른 화구에서는 베이컨을 굽고, 토스터기에 빵을 넣는다.

재료들이 가열되는 동안 할게 없으니 오랜지 주스를 따른다.

<Br>

그럼 우리는 왜 이렇게 행동할까? 

바로, <span class="post-highlight">시간이 오래 걸리는 작업을 계속 붙잡고 있으면 병목이 생기는 것을</span> 무의식적으로 알고 있기 때문이다.

**왼쪽 방식에서는 계란 후라이가 구워질 때 계란 후라이를 조리하느라 아무것도 못하고 대기하기에,**

오른쪽 방식보다 시간이 더 오래 걸리는 것이다.

<br>

비동기 프로그래밍도 똑같다. `Main Thread`에서 모든 작업을 처리하게 된다면, 시간이 오래걸리는 작업이 병목이 되어 프로그램 전체가 멈추는 느낌을 받게 될 수 있다.

따라서 이를 해결하기 위해 **`Main Thread` 대신 다른 Thread에서 시간이 오래걸리는 작업을 처리하는 것이다.**

실제로 UI 어플리케이션의 경우, 실행에 `50ms` 이상 소요되는 메서드는 `Async`로 만들어 처리하는 것을 권장하고 있다.

( ex. I/O 작업, 네트워크 작업 등 )

<br><br>

---

## 🔷 C# 에서의 비동기 프로그래밍

### 🔶 Thread

그렇다면 C#에서는 이 비동기를 구현하기 위해 어떻게 해야하는가?

(앞에서 약간 스포했지만,) 바로 <span class="post-highlight">Thread</span>이다. Thread는 익히 알다시피, **프로세스내의 실행 흐름 단위**라고 볼수 있는데

오래 걸리는 작업은 새로운 Thread를 만들어 실행하게 되면 Main Thread의 부담이 줄어들 수 있게 된다.

Thread를 만드는 방법은 여러가지가 있는데, 대표적으로는 `Thread`객체를 만드는 방법이 있다.

``` csharp
using System;
using System.Threading;

class Program 
{
    public static void Foo() 
    {
        Console.WriteLine("Foo Start");
        Thread.Sleep(2000);
        Console.WriteLine("Foo End");
    }
    
    public static void Main() 
    {
        Console.WriteLine("Main Start");
        Thread t = new Thread(Program.Foo);
        t.Start();
        Console.WriteLine("Main End");
    }
}
```

위 프로그램을 실행하면, 다음과 같이 출력된다.

```
Main Start
Foo Start
Main End
Foo End
```

Thread의 특징으로는, 운영체제의 최소 실행단위로서 개발자가 직접 제어 해야 한다는 것이 있다.

생성과 시작, 중지 및 소멸까지도 직접 컨트롤 해야 한다는 뜻은, 그만큼 정밀한 제어가 가능하다는 뜻이기도 하지만

동기화 문제, 데드락 등 여러 골치아픈 문제까지 직접 신경써야 한다는 의미이므로 요즘에는 잘 사용되지 않는다.

<br>

### 🔶 Task

그리하여, `.NET Framework 4` 부터 도입된 비동기 작업을 추상화한 클래스인 `Task`가 도입되었다.

`Task` 내부적으로는 `ThreadPool` 을 사용하여 비동기 작업을 지원하므로

개발자가 여러가지 골치아픈 문제를 신경쓰지 않아도 된다는 장점이 있다.

|  | Thread | Task |
|:---:|:---:|:---:|
| 정의 | OS의 최소 실행 단위 | 비동기 작업을 추상화한 클래스 |
| 효율성 | 직접 제어 | Thread pool 기반의 효율적 스레딩 |
| 사용성 | 생성, 시작, 중지 등 직접 관리 필요 | 세부 작업 내부 처리, 로직에 집중 가능 |
| 코드 복잡성 | 동기화 문제, 데드락 등 해결 필요 | `Task<T>` 형태로 반환 가능 |
| 비동기 지원 | 직접 지원 불가 | `async/await` 문법 지원 |

> 참고자료 : [준세 단칸방 | C# 비동기 프로그래밍 : Thread와 Task 차이점](https://wjunsea.tistory.com/141)

개발자가 비동기 작업을 구현할 때, Thread 보다 손쉽게 구현할 수 있도록 지원해주는 클래스라 보면 되겠다.

<br><br>

---

## 🔷 Unity에서 비동기 프로그래밍

### 🔶 Thread-safe 하지 않은 Unity 엔진

주제를 시작하기 앞서, Unity의 큰 특징 중 하나를 짚고 넘어가고자 한다.

Unity는 <span class="post-highlight">단일 스레드를 기반으로 설계된 아키텍처</span>이다.

이 말은 **멀티 스레드를 전혀 지원하지 않는다** 라는 말이 **아니다**.

단일 스레드 기반으로 설계 되었다는 뜻은 엔진 자체가 `Thread-safe` 하지 않다는 뜻으로,

UnityEngine에서 정의한 Object들을 Main Thread에서 제어할 수 없다는 뜻이다.

(마치 `Single-Threaded Apartment` 구조처럼, 해당 작업은 `Main Thread`에서만 접근이 가능하다.)

따라서 다음과 같은 작업은 Main Thread 외부에서 할 수 없다.

* `UnityEngine.object`를 상속받은 객체 (GameObject, Texture2D 등) 을 생성, 삭제
* 객체의 `Transform` 정보 (Position, Rotation, Scale ...) 를 변경

``` csharp
public void Start()
{
    Task.Run(() => 
    {
        await MyAsyncFunc();
    });
}

private async Task<int> MyAsyncFunc()
{
	await Task.Delay(1000);
 
    this.transform.localPosition += Vector3.up;

	return 1;
}
```

따라서, Unity Engine 객체를 다른 Thread 또는 Task에서 다루려면 `Dispatcher`를 선언한 후 이용하는 등의 작업이 필요하다.

``` csharp
private Queue<Vector3> myQueue;

public void Start()
{
    myQueue = new Queue<Vector3>();
    Task.Run(() => 
    {
        await MyAsyncFunc();
    });
}

private void Update() 
{
    if(myQueue.count > 0)
    {
        var vec = myQueue.Dequeue();
        this.transform.localPosition += vec;
    }
}

private async Task<int> MyAsyncFunc()
{
	await Task.Delay(1000);
 
    myQueue.Enqueue(Vector3.up);

	return 1;
}

```

<br><br>

---

## 🔷 UniTask

### 🔶 UniTask




<br><br>

> 📢 **알림**
>
> 본 포스트의 썸네일 이미지와 상단 배경 이미지는 GPT4를 통해 생성한 이미지를 후보정 한 것입니다.